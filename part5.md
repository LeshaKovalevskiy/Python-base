## Содержание 
 - [28.Итератор и итерируемые объекты. Функции iter и next](#28итератор-и-итерируемые-объекты-функции-iter-и-next)
 - [29.Вложеннные циклы](#29вложеннные-циклы)
 - [30.List comprehension](#30list-comprehension)
 - [31.Создание и обработка вложенных списков](#31создание-и-обработка-вложенных-списков)
 - [32.Матрицы](#32матрицы)
 - [33.Вложенные циклы в list comprehensions и вложенные list comprehensions](#33вложенные-циклы-в-list-comprehensions-и-вложенные-list-comprehensions)

## 28.Итератор и итерируемые объекты. Функции iter и next

<h3 align="center">Итерируемые объекты</h3>

В языке `Python` под **итерируемым объектом** подразумевают объект, который можно итерировать, то есть проходиться по нему, перебирая каждый элемент раз за разом. К
примеру, списки (тип `list`), строки (тип `str`) являются итерируемыми, поскольку мы можем перебирать каждый элемент этих объектов.

Приведенный ниже код:

```python
numbers = [1, 2, 3]
name = 'python'

for num in numbers:        # итерируем по списку, перебирая каждый элемент
    print(num)

for c in name:             # итерируем по строке, перебирая каждый символ
    print(c)

print(2 in numbers)        # неявное итерирование по списку
print('A' in name)         # неявное итерирование по строке
print(*numbers)            # неявное итерирование по списку при распаковке
```

выводит:

```python
1
2
3
p
y
t
h
o
n
True
False
1 2 3
```

Если подходить более формально в Python, существует два типа итерируемых объектов:

  1. итераторы
  2. коллекции и последовательности

<h4 align="center">Итераторы</h4>

**Итератор** — специальный объект, который выдает свои элементы по одному за раз.

Если итератор передать во встроенную функцию `next()`, то эта функция вернет его следующий элемент. При этом сам итератор также сдвинется на следующий элемент.
При следующем вызове функция `next()` вернет следующий элемент и т.д. Если же в итераторе элементов больше не осталось, то вызов функции `next()` приведет к
возникновению исключения `StopIteration`. После этого итератор перебирать больше не получится, необходимо будет создавать новый итератор.

```python
numbers = [1, 2, 3]

iterator = iter(numbers)          # создаем итератор на основе списка

print(next(iterator))             # запрашиваем и печатаем первый элемент итератора
print(next(iterator))             # запрашиваем и печатаем второй элемент итератора
print(next(iterator))             # запрашиваем и печатаем третий элемент итератора

print(next(iterator))             # возбуждается исключение StopIteration
```

![image](https://user-images.githubusercontent.com/124737857/229821702-7dd8741b-73b3-43a6-a405-6c15efa2e612.png)

<h4 align="center">Коллекции и последовательности</h4>

**Коллекция** — объект, хранящий набор значений одного или различных типов, позволяющий обращаться к этим значениям, а также применять специальные функции и методы,
зависящие от типа коллекции.

Также среди коллекций можно выделить те, элементы которых пронумерованы индексами и расположены в строгом порядке. Такие коллекции называются **последовательностями**.
Например, списки, строки и кортежи являются последовательностями.

Коллекции не являются итераторами сами по себе, но позволяют создать итератор на своей основе.

Для того чтобы создать итератор на основе некоторой коллекции, достаточно вызвать встроенную функцию `iter()`, передав нужную коллекцию в качестве ее аргумента.

Например, список не является итератором, но на его основе можно создать сколько угодно итераторов, каждый из которых будет перебирать элементы списка от первого до
последнего:

```python
numbers = [1, 2, 3]

iterator = iter(numbers)          # создаем итератор на основании списка
```

Основная разница между последовательностями и итераторами, заключается в том, что в последовательностях элементы пронумерованы индексами, начиная от нуля. Мы можем
обратиться к конкретному элементу таких объектов по индексу. В итераторах мы можем лишь последовательно запрашивать следующий элемент.

Приведенный ниже код:

```python
numbers = [1, 2, 3, 4]            # список
letters = ('a', 'b', 'c')         # кортеж
language = 'python'               # строка

print(numbers[3])                 # обращение по индексу
print(letters[2])                 # обращение по индексу
print(language[5])                # обращение по индексу
```

выводит:

```
4
c
n
```

Приведенный ниже код:

```python
letters = ('a', 'b', 'c')

iterator = iter(letters)           # создаем итератор на основе кортежа

print(iterator[1])                 # обращение по индексу
```

приводит к возникновению исключения:

```python
TypeError: 'tuple_iterator' object is not subscriptable
```

<h3 align="center">Преимущества итераторов</h3>

Основными преимуществами использования итераторов являются:

 - однотипность работы с объектами разных типов

 - ленивые вычисления и экономия потребляемой памяти

 - комбинация множества итераторов для создания понятной и читабельной программы

<h4 align="center">Однотипность работы с объектами разных типов</h4>

Итераторы позволяют разным объектам притворяться одинаковыми. Списки, кортежи, строки, множества, словари, объекты типа `range` имеют разные типы, но мы можем
использовать любой из этих объектов:

 - в цикле `for`

 - в функциях высшего порядка `map()`, `filter()`, `reduce()`, `reversed()` и т.д.

 - для проверки наличия некоторого значение с помощью оператора принадлежности `in`

 - для распаковки элементов помощью `*` и т.д.

Цикл `for` в Python работает по следующему принципу:

 - создает итератор на основе итерируемого объекта

 - запрашивает очередной элемент из итератора с помощью функции `next()` и передает его в выполняемый блок кода (тело цикла)

 - останавливается при получении исключения `StopIteration`

Благодаря этому, в цикл `for` можно передать и список, и кортеж, и строку, и объект типа `range`, и многие другие объекты, которые имеют свои итераторы.

По сути, приведенный ниже код:

```python
numbers = [1, 2, 3, 4]

for num in numbers:
    print(num)
```    
    
за кулисами превращается в:

```python
numbers = [1, 2, 3, 4]

iterator = iter(numbers)           # создается итератор

while True:
    try:
        item = next(iterator)
        print(item)
    except StopIteration:
        break
```

<h4 align="center">Ленивые вычисления и экономия потребляемой памяти</h4>

Ленивые вычисления предполагают, что не нужно ничего делать до тех пор, пока в этом нет необходимости. Это не просто удобно, но и позволяет экономить память и время
на вычисление.

Рассмотрим на примере `range`(не является итератором, но работает схожим образом): 

```python
numbers = range(5)             # 5 чисел в последовательности

for num in numbers:
    print(num)
```    
    
выводит:

```
0
1
2
3
4
```

Цикл `for` создает на основе объекта `range` итератор, у которого запрашивает элементы по одному, пока не будет достигнут конец последовательности чисел. В нашем
примере, пока не будет получено число 4.

Важно понимать, что объект типа `range` не хранит весь набор чисел. Он создает новое число (на лету) только тогда, когда оно потребуется, при этом старые значения
не хранятся. Размер объектов `range` не зависит от количества чисел, которые предполагается перебрать, ведь нужно помнить только начальное и конечное значения
последовательности, шаг и текущее значение.

Приведенный ниже код:

```python
from sys import getsizeof

numbers1 = range(5)                  # 5 чисел в последовательности
numbers2 = range(100000)             # 100000 чисел в последовательности
numbers3 = range(10000000000000)     # 10000000000000 чисел в последовательности

print(getsizeof(numbers1))
print(getsizeof(numbers2))
print(getsizeof(numbers3))
```

выводит (размер в байтах):

```
48
48
48
```

Все объекты `range` имеют один и тот же размер в памяти — 48 байт. Такой подход позволяет создавать "большие" итераторы (даже бесконечные), не занимая много памяти.

Мы можем преобразовать любой итерируемый объект в список. Однако при таком преобразовании все элементы итерируемого объекта будут записаны в память.Чем больше
элементов в списке, тем больше памяти он занимает. Преобразование итерируемого объекта в список не всегда будет заканчиваться удачно.

Приведенный ниже код:

```python
from sys import getsizeof

numbers3 = list(range(10000000000000))     # 10000000000000 чисел в списке
print(getsizeof(numbers3))
```

приводит в возникновению исключения `MemoryError`. Python не позволяет создать такой большой список.

> Объекты типа range являются ленивыми, преобразовывать их в списки стоит с особенной аккуратностью и только тогда, когда это действительно необходимо.

<h4 align="center">Комбинация множества итераторов</h4>

У итераторов есть замечательная особенность: их можно комбинировать. Это позволяет вместо огромных циклов с перемешанными этапами обработки писать небольшие блоки, которые стыкуются друг с другом.

Приведенный ниже код:

```python
sentence = 'In the face of ambiguity refuse the temptation to guess'

filter_iterator = filter(lambda word: len(word) > 4, sentence.split())   # фильтруем
map_iterator = map(lambda word: word.upper(), filter_iterator)           # преобразовываем
enumerate_iterator = enumerate(map_iterator, 1)                          # нумеруем

for index, value in enumerate_iterator:                                  # выводим
    print(f'{index}. {value}')
```    
   
выводит:

```
1. AMBIGUITY
2. REFUSE
3. TEMPTATION
4. GUESS
```

Обратите внимание на то, что все три объекта `filter_iterator`, `map_iterator`, `enumerate_iterator` являются итераторами. Они не хранят все данные в памяти, а
создают и выдают их по мере того, как их запрашивают. Другими словами, при обращении к очередному элементу `enumerate_iterator` произойдет последовательное обращение
сначала к элементу `map_iterator`, а затем к элементу `filter_iterator`.

> Имейте в виду, что от порядка, в котором комбинируются итераторы, зависит итоговый результат.

<h3 align="center">Примечания</h3>

**Примечание 1**. Встроенной функции `next()` можно передать второй аргумент, который будет возвращен вместо возбуждения исключения `StopIteration`, если в итераторе
больше не осталось элементов.

Приведенный ниже код:

```python
nums = iter([1, 2, 3, 4])

print(next(nums))
print(next(nums))
print(next(nums))
print(next(nums))
print(next(nums, -1))
```

выводит:

```
1
2
3
4
-1
```

**Примечание 2**. Коллекции не являются итераторами. Поэтому встроенная функция next() не позволяет получить очередной элемент, например списка,
строки и т.д.

Приведенный ниже код:

```python
nums = [1, 2, 3, 4]

print(next(nums))
```

приводит к возникновению исключения:

```python
TypeError: 'list' object is not an iterator
```

**Примечание 3**. Итераторы могут **генерировать бесконечное число значений**, не занимая много дополнительной памяти. Например, итератор может генерировать все
натуральные числа или все простые числа. Или генерировать значения, количество которых заранее неизвестно.

Встроенная функция `len()` не работает с **итераторами**, потому что длина итераторов может быть очень большой или даже бесконечной. В действительности функция `len()`
за кулисами вызывает магический метод `__len__()`. У итераторов его нет, значит и функция к ним не применима.

Приведенный ниже код:

```python
numbers = [1, 2, 3, 4, 5, 6]

evens = filter(lambda num: num % 2 == 0, numbers)
print(len(evens))
```

приводит к возникновению ошибки:

```python
TypeError: object of type 'filter' has no len()
```

Все встроенные типы коллекций(`list`, `tuple`, `str` и т.д.) хранят свою длину, поэтому метод `__len__()`(функция `len()`) работает за постоянное время `O(1)`

**Примечание 4**. Подробнее о возможностях типа `range` можно почитать по [ссылке](https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/klass-range/) и [тут](https://webdevblog.ru/python-range-ne-yavlyaetsya-iteratorom/?ysclid=l6fb8f454e859972646) .

**Примечание 5**. Обратите внимание на то, что на основе одного списка (кортежа, строки, множества, словаря и т.д.) мы можем создавать множество несвязанных между
собой итераторов. Каждый из них будет независимо от других перемещаться от начала до конца.

Приведенный ниже код:

```python
numbers = list(range(1, 10))

iterator1 = iter(numbers)
iterator2 = iter(numbers)
iterator3 = iter(numbers)

print(numbers)

print(next(iterator1))
print(next(iterator1))

print(next(iterator2))

print(next(iterator3))
print(next(iterator3))
print(next(iterator3))
print(next(iterator3))
print(next(iterator3))
```

выводит:

```
[1, 2, 3, 4, 5, 6, 7, 8, 9]
1
2
1
1
2
3
4
5
```

![image](https://user-images.githubusercontent.com/124737857/229862829-a40b3fd1-b69b-40a1-9e10-b76c1be68907.png)

**Примечание 6**. У числовых последовательностей range можно узнать длину:

```python
numbers1 = range(5)                  # 5 чисел в последовательности
numbers2 = range(100000)             # 100000 чисел в последовательности
numbers3 = range(10000000000000)     # 10000000000000 чисел в последовательности

print(len(numbers1))
print(len(numbers2))
print(len(numbers3))
```

выводит:

```
5
100000
10000000000000
```

**Примечание 7**. Важно понимать разницу между итерируемыми объектами и итераторами:

 - `iterable` (итерируемый) — это свойство того, по кому будет происходить итерирование

 - `iterator` (итерирующий) — это тот, кто ходит

Другими словами, `iterable` — сущность, по которой ходим, книга, которую листаем, а `iterator` — листающая сущность, палец, который указывает на нужный лист в книге.

**Примечание 8**. Классифицировать контейнерный тип данных в `Python`, то есть определить, является ли он, например, последовательностью, можно проверкой наличия соответствующих методов. Подробнее по [ссылке](https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes).

![image](https://user-images.githubusercontent.com/124737857/229862924-ef698373-e606-4ae8-8b67-27095342855b.png)

## Задания:

1. Вам доступен список `numbers`, содержащий целые числа. Дополните приведенный ниже код с использованием функций `iter()` и `next()`, чтобы он вывел четвертый
элемент данного списка.

```python
numbers = [100, 70, 34, 45, 30, 83, 12, 83, -28, 49, -8, -2, 6, 62, 64, -22, -19, 61, 13, 5, 80,
          -17, 7, 3, 21, 73, 88, -11, 16, -22]

cnt = 0
it = iter(numbers)
while cnt < 3:
    next(it)
    cnt += 1
print(next(it))
```

2. Вам доступен список `numbers`, содержащий целые числа. Дополните приведенный ниже код с использованием функций `iter()` и `next()`, чтобы он вывел последний
элемент данного списка.

```python
numbers = [100, 70, 34, 45, 30, 83, 12, 83, -28, 49, -8, -2, 6, 62, 64, -22, -19, 61, 13, 5, 80,
           -17, 7, 3, 21, 73, 88, -11, 16, -22]
iterator = iter(numbers)
while True:
    try:
        res = next(iterator)
    except StopIteration:
        print(res)
        break
```

3. Вводится строка. Нужно создать итератор для перебора символов этой строки. Затем, перебрать через созданный итератор все 
символы до первого пробела. В процессе перебора символы выводить на экран в одну строчку друг за другом (без пробелов). 
Гарантируется, что во введенной строке имеется хотя бы один пробел.

```python
s = iter(input())
elem = next(s)
while elem != " ":
    print(elem, end="")
    elem = next(s)
```

4. Вводится четырехзначное целое положительное число. Подумайте, как можно определить итератор для перебора его цифр. 
Выведите цифры этого введенного числа (с помощью итератора) в одну строчку через пробел.

```python
s_it = iter(input())
while True:
    try:
        print(next(s_it), end=" ")
    except StopIteration:
        break
```

## 29.Вложеннные циклы

Вложенный цикл расположен в еще одном цикле. Часы служат хорошим примером работы вложенного цикла. Секундная, минутная и часовая стрелки вращаются вокруг циферблата.
Часовая стрелка смещается всего на 1 шаг для каждых 60 шагов минутной стрелки. И секундная стрелка должна сделать 60 шагов для 1 шага минутной стрелки.

Пример вложенных циклов для реализации часов:

```python
for hours in range(24):
    for minutes in range(60):
        for seconds in range(60):
            print(hours, ':', minutes, ':', seconds)
```

Результатом работы такого кода будет:

```
0 : 0 : 0
0 : 0 : 1
0 : 0 : 2
...
23 : 59 : 58
23 : 59 : 59 
```

Когда самый внешний цикл сделает 24 итерации, средний сделает 1440 итераций, и самый внутренний цикл сделает 86400 итераций.

Пример имитационной модели часов подводит нас к нескольким моментам, имеющим отношение к вложенным циклам:

 - вложенный цикл выполняет все свои итерации для каждой отдельной итерации внешнего цикла;
 - вложенные циклы завершают свои итерации быстрее, чем внешние циклы;
 - для того, чтобы получить общее количество итераций вложенного цикла, надо **перемножить** количество итераций всех циклов.

> Можно вкладывать как циклы `for`, так и `while`.


<h3 align="center">Операторы break и continue во вложенных циклах</h3>

Оператор `break` выполняет прерывание **ближайшего** цикла в котором он расположен. Аналогично, оператор `continue` осуществляет переход на следующую итерацию
**ближайшего** цикла.

Рассмотрим программный код:

```python
for i in range(3):
    for j in range(3):
        print(i, j)
```

Результатом его выполнения будут 9 строк:

```
0 0
0 1
0 2
1 0
1 1
1 2
2 0
2 1
2 2
```

Изменим код, добавив во вложенный цикл условный оператор с оператором `break`:

```python
for i in range(3):
    for j in range(3):
        if i == j:
            break
        print(i, j)
```

Результатом выполнения нового кода будут 3 строки:

```
1 0
2 0
2 1
```

Изменим оператор прерывания `break` на оператор `continue`:

```python
for i in range(3):
    for j in range(3):
        if i == j:
            continue
        print(i, j)
```

Результатом выполнения нового кода будут 6 строк:

```
0 1
0 2
1 0
1 2
2 0
2 1
```

> Нужно избегать большого количества вложенных циклов, так как код может медленно работать

## Задания

1. Дано нечетное натуральное число n. Напишите программу, которая печатает равнобедренный звездный треугольник с основанием, 
равным n в соответствии с примером:

```
*
**
***
****
***
**
*
```

```python
n = int(input())
for i in range(1, n + 1):
    for j in range(i):
        if i > n - j:
            break
        print("*", end="")
    print()
```

2. Напишите программу, которая выводит часть последовательности 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 ... (число повторяется столько 
раз, чему равно). На вход программе передаётся неотрицательное целое число n — столько элементов последовательности должна 
отобразить программа. На выходе ожидается последовательность чисел, записанных через пробел в одну строку.

Например, если n = 7, то программа должна вывести 1 2 2 3 3 3 4.

```python
n = int(input())
i = 1
s = 0
while n:
    if s < i:
        s += 1
    else:
        i += 1
        s = 1
    print(i, end=" ")
    n -= 1
```

```python
# 2 способ
n = int(input())
i = 1
s = 0
lst = []
while s <= n:
    lst.extend([i] * i)
    s += i
    i += 1
print(*lst[:n])  
```

3. Когда Павел учился в школе, он запоминал таблицу умножения прямоугольными блоками. Для тренировок ему бы очень пригодилась
программа, которая показывала бы блок таблицы умножения.

Напишите программу, на вход которой даются четыре числа `a`, `b`, `c` и `d`, каждое в своей строке. Программа должна вывести фрагмент 
таблицы умножения для всех чисел отрезка `[a;b]` на все числа отрезка `[c;d]`.

Числа a, b, c и d являются натуральными и не превосходят 10, a≤b, c≤d.

Следуйте формату вывода из примера, для разделения элементов внутри строки используйте `'\t'` — символ табуляции. Заметьте, 
что левым столбцом и верхней строкой выводятся сами числа из заданных отрезков — заголовочные столбец и строка таблицы.

```python
a, b = int(input()), int(input())
c, d = int(input()), int(input())
for i in range(c, d + 1):
    print(f"\t{i}", end="")
print()
for i in range(a, b + 1):
    print(i, end="\t")
    for j in range(c, d + 1):
        print(i * j, end="\t")
    print()
```

4. Решите уравнение в натуральных числах `28n+30k+31m=365`.

```python
for n in range(1, 14):
    for k in range(1, 13):
        for m in range(1, 12):
            if 28 * n + 30 * k + 31 * m == 365:
                print(n, k, m)
```

5. Имеется 100 рублей. Сколько быков, коров и телят можно купить на все эти деньги, если плата за быка – 10 рублей, за корову – 5 рублей, за теленка – 0.5 рубля
и надо купить 100 голов скота?

```python
for bull in range(11):
    for cow in range(21):
        for calf in range(201):
            if 10 * bull + cow * 5 + calf * 0.5 == 100 and bull + cow + calf == 100:
                print(bull, cow, calf)
```

6. Напишите код, выводящий следующее, при n = 9:

```
                1                 
              1 2 1               
            1 2 3 2 1             
          1 2 3 4 3 2 1           
        1 2 3 4 5 4 3 2 1         
      1 2 3 4 5 6 5 4 3 2 1       
    1 2 3 4 5 6 7 6 5 4 3 2 1     
  1 2 3 4 5 6 7 8 7 6 5 4 3 2 1   
1 2 3 4 5 6 7 8 9 8 7 6 5 4 3 2 1 
  1 2 3 4 5 6 7 8 7 6 5 4 3 2 1   
    1 2 3 4 5 6 7 6 5 4 3 2 1     
      1 2 3 4 5 6 5 4 3 2 1       
        1 2 3 4 5 4 3 2 1         
          1 2 3 4 3 2 1           
            1 2 3 2 1             
              1 2 1               
                1                              
```

```python
n = int(input())
for i in range(1, n + 1):
    
    for j in range(n - i):
        print(" ", end=" ")
        
    for j in range(i):
        print(j + 1, end=" ")
        
    for j in range(i - 1, 0, -1):
        print(j, end=" ")
        
    for j in range(n - i):
        print(" ", end=" ")
        
    print()
    
for i in range(n):
    
    for j in range(i + 1):
        print (" ", end=" ")
        
    for j in range(1, n - i):
        print(j, end=" ")
    
    for j in range(n - i - 2, 0, -1):
        print(j, end=" ")
        
    for j in range(i + 1):
        print(" ", end=" ")
        
    print()
```

7. На вход программе подается два натуральных числа a и b (a < b). Напишите программу, которая находит натуральное число из
отрезка [a;b] с максимальной суммой делителей.

**Формат выходных данных**

Программа должна вывести два числа на одной строке, разделенных пробелом: число с максимальной суммой делителей и сумму его
делителей.

```python
mx = 0
mx_number = 0
a, b = int(input()), int(input())
for num in range(a, b + 1):
    total = 0
    i = 1
    while i ** 2 <= num:
        if num % i == 0:
            total += i
            if i != num // i:
                total += num // i
        i += 1
    if total >= mx:
        mx = total
        mx_number = num
print(mx_number, mx)
```

8. На вход программе подается натуральное число n. Напишите программу, которая находит цифровой корень данного числа. Цифровой
корень числа n получается следующим образом: если сложить все цифры этого числа, затем все цифры найденной суммы и повторить 
этот процесс, то в результате будет получено однозначное число (цифра), которое и называется цифровым корнем данного числа.

```python
n = int(input())
while n > 9:
    a = 0
    while n:
        a += n % 10
        n //= 10
    n = a
print(n)
```

## 30.List comprehension

<h3 align="center">Списочные выражения</h3>

В Python есть механизм для создания списков из неповторяющихся элементов. Такой механизм называется — **списочное выражение** (list comprehension).

Создание и заполнение списка числами от 0 до 9:

```python
numbers = []
for i in range(10):
    numbers.append(i)
```

Можно записать следующим образом:

```python
numbers = [i for i in range(10)]
```

Общий вид списочного выражения следующий:

```
[<способ формирования значения> for <переменная> in <итерируемый объект>]
```

где `переменная` — имя некоторой переменной, `итерируемый объект` — любой итерируемый объект(например, список, строка), `способ формирования значения` — некоторое
выражение, как правило, зависящее от использованной в списочном выражении переменной, которым будут заполнены элементы списка.

> Переменная используемая внутри list comprehension, доступна только внутри его. За пределами list comprehension она не существует 

<h4 align="center">Примеры использования списочных выражений</h4>

1. Создать список, заполненный 10 нулями:

```python
zeros = [0 for i in range(10)]
```

однако в данных случаях используют более короткую запись 

```python
zeros = [0] * 10
```

2. Создать список, заполненный квадратами целых чисел от 0 до 9 можно так:

```python
squares = [i ** 2 for i in range(10)]
```

3. Создать список, заполненный кубами целых чисел от 10 до 20 можно так:

```python
cubes = [i ** 3 for i in range(10, 21)]
```

<h4 align="center">Условия в списочном выражении</h4>

В списочных выражениях можно использовать условный оператор. Например, если требуется создать список четных чисел от 0 до 20, то мы можем написать такой код:

```python
evens = [i for i in range(21) if i % 2 == 0]
```

При необходимости можем использовать тернарный условный оператор, внутри list comprehension:

```python
d = [5, 9, 3, 2, -3, -1, -50]
lst = ["четное" if x % 2 == 0 else "нечетное" for x in d]
```

Или же совмещать условный оператор и тернарный(при этом для лучшей читаемости list comprehension можно писать в несколько строчек)

```python
d = [5, 9, 3, 2, -3, -1, -50]
lst = ["четное" if x % 2 == 0 else "нечетное"
      for x in d
      if x > 0
      ]
```

## Задания

1. Необходимо получить следующий список букв: ['A', 'BB', 'CCC', 'DDDD', 'EEEEE', 'FFFFFF', ...]

**Входные данные**

На вход программе подается натуральное число n, n ≤ 26.

```python
print([chr(ord("A") + i) * (i + 1) for i in range(int(input()))])
```

2. На вход программе подается строка текста. Напишите программу, использующую списочное выражение, которая преобразует каждое
слово введенного текста в "молодежный жаргон" по следующему правилу: 

 - первая буква каждого слова удаляется и ставится в конец слова; 
 - затем в конец слова добавляется слог "ки".

```python
a = input().split()
print(*[c[1:] + c[0] + 'ки' for c in a])
```

3. Вводится список в формате: 
<город 1> <численность населения 1> <город 2> <численность населения 2> ... <город N> <численность населения N>
Необходимо с помощью `list comprehension` сформировать список `lst`, содержащий вложенные списки из пар:
`<город> <численность населения>`
Численность населения - целое число в тыс. человек. Вывести результат на экран в виде списка командой: `print(lst)`

```python
info = input().split()
lst = [[info[i], int(info[i + 1])] for i in range(0, len(info), 2)]
print(lst)
```

## 31.Создание и обработка вложенных списков

<h3 align="center">Создание вложенных списков</h3>

Для создания вложенного списка можно использовать литеральную форму записи – перечисление элементов через запятую в квадратных скобках:

```python
my_list = [[0], [1, 2], [3, 4, 5]]
```

Иногда нужно создать вложенный список, заполненный по определенному правилу – шаблону. Например, список длиной n, содержащий списки длиной m, каждый из которых
заполнен нулями.

Рассмотрим несколько способов решения задачи.

**Способ 1**. Создадим пустой список, потом n раз добавим в него новый элемент – список длины m, составленный из нулей:

```python
n, m = int(input()), int(input())    # считываем значения n и m
my_list = []

for _ in range(n):
    my_list.append([0] * m)

print(my_list)
```

Если ввести значения n = 3, m = 5, то результатом работы такого кода будет:

```
[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]
```

**Способ 2**. Сначала создадим список из n элементов (для начала просто из n нулей). Затем сделаем каждый элемент списка ссылкой на другой список из m элементов,
заполненный нулями:

```python
n, m = int(input()), int(input())    # считываем значения n и m
my_list = [0] * n

for i in range(n):
    my_list[i] = [0] * m

print(my_list)
```

**Способ 3**. Можно использовать генератор списка: создадим список из n элементов, каждый из которых будет списком, состоящих из m нулей:

```python
n, m = int(input()), int(input())    # считываем значения n и m

my_list = [[0] * m for _ in range(n)]

print(my_list)
```

Очевидное решение, использующее операцию умножения списка на число (операция повторения) оказывается неверным:

```python
n, m = int(input()), int(input())    # считываем значения n и m

my_list = [[0] * m ] * n

print(my_list)
```

В этом легко убедиться, если присвоить элементу `my_list[0][0]` любое значение, например, 17, а затем вывести список на печать:

```python
my_list[0][0] = 17

print(my_list)
```

Если ввести значения `n = 5`, `m = 3`, то результатом работы будет:

```
[[17, 0, 0], [17, 0, 0], [17, 0, 0], [17, 0, 0], [17, 0, 0]]
```

То есть, изменив значение элемента списка `my_list[0][0]` мы также изменили значения элементов `my_list[1][0]`, `my_list[2][0]`, `my_list[3][0]`, `my_list[4][0]`.
Так как хранится n ссылок на один и тот же список.

<h3 align="center">Считывание вложенных списков</h3>

```python
n = 4                                          # количество строк (элементов)
my_list = []

for _ in range(n):
    elem = [int(i) for i in input().split()]   # создаем список из элементов строки
    my_list.append(elem)
```    

В результате, если на вход программе подаются строки

```
2 4
6 7 8 9
1 3
5 6 5 4 3 1
```

то в переменной `my_list` будет храниться список:

```
[[2, 4], [6, 7, 8, 9], [1, 3], [5, 6, 5, 4, 3, 1]]
```

<h3 align="center">Перебор и вывод элементов вложенного списка</h3>

Для доступа к элементу списка указывают индекс в квадратных скобках:

```python
my_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

print(my_list[0][0])  # 1
print(my_list[1][2])  # 6
print(my_list[2][1])  # 8
```

Когда нужно перебрать все элементы вложенного списка (например, чтобы вывести их на экран), обычно используются вложенные циклы:

```python
my_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

for i in range(len(my_list)):
    for j in range(len(my_list[i])):
        print(my_list[i][j], end=' ')   # используем необязательный параметр end
    print()                             # перенос на новую строку
``` 
 
Результатом работы такого кода будет:

```
1 2 3 
4 5 6 
7 8 9
```

Можно перебирать не индексы, а сразу сами элементы вложенного списка:

```python
my_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

for row in my_list:
    for elem in row:
        print(elem, end=' ')
    print()
```

## Задания

1. Вводится список из URL-адресов (каждый с новой строки). Требуется в них заменить все пробелы на символ дефиса (-). Следует 
учесть, что может быть несколько подряд идущих пробелов. Результат преобразования вывести на экран в виде строк из 
URL-адресов.

```python
d = ["django chto  eto takoe    poryadok ustanovki",
"model mtv   marshrutizaciya funkcii  predstavleniya",
"marshrutizaciya  obrabotka isklyucheniy       zaprosov perenapravleniya"]

for row in d:
    while row.count("  "):
        row = row.replace("  ", " ")
    row = row.replace(" ", "-")
    print(row)
```

```python
# 2 способ
d = ["django chto  eto takoe    poryadok ustanovki",
"model mtv   marshrutizaciya funkcii  predstavleniya",
"marshrutizaciya  obrabotka isklyucheniy       zaprosov perenapravleniya"]
for row in d:
    row = "-".join(row.split())
    print(row)
```

2. На вход программе подается строка текста, содержащая символы. Напишите программу, которая упаковывает последовательности
одинаковых символов заданной строки в подсписки.

```python
letters = input().split()
lst, res = [], []
for i in range(len(letters) - 1):
    res.append(letters[i])
    if letters[i] != letters[i + 1]:
        lst.append(res)
        res = []
res.append(letters[-1])
lst.append(res)
print(lst)
```

3. На вход программе подаются две строки, на одной символы, на другой число `n`. Из первой строки формируется список. Реализуйте функцию `chunked()`, которая
принимает на вход список и число, задающее размер чанка (куска), а возвращает список из чанков указанной длины.

```python
def chunked(lst, number):
    res_lst = []
    for i in range(0, len(lst), number):
        res = lst[i:number + i]
        res_lst.append(res)
    return res_lst

letters = input().split()
n = int(input())
print(chunked(letters, n))
```

4. Подсписок — часть другого списка. Подсписок может содержать один элемент, несколько, и даже ни одного. Например, `[1]`, `[2]`, `[3]` 
и `[4]` — подсписки списка `[1, 2, 3, 4]`. Список `[2, 3]` — подсписок списка `[1, 2, 3, 4]`, но список `[2, 4]` не подсписок списка 
`[1, 2, 3, 4]`, так как элементы `2` и `4` во втором списке не смежные. Пустой список — подсписок любого списка. Сам список — 
подсписок самого себя, то есть список `[1, 2, 3, 4]` подсписок списка `[1, 2, 3, 4]`. На вход программе подается строка текста, содержащая символы. Из данной
строки формируется список. Напишите программу, которая выводит список, содержащий все возможные подсписки списка, включая пустой список.

```python
letters = input().split()
n = len(letters)
res_lst = []
res_lst.append([])
for i in range(1, n + 1):
    for j in range(n + 1 - i):
        res = letters[j:i + j]
        res_lst.append(res)
print(res_lst)
```

5. На вход программе подается строка текста, содержащая символы и число `n`. Из данной строки формируется список. Напишите 
программу, которая разделяет список на вложенные подсписки так, что `n` последовательных элементов принадлежат разным 
подспискам.

Примечание. Графическая иллюстрация:

![image](https://user-images.githubusercontent.com/124737857/230112558-ee95b661-eec7-44fd-84ce-b192bd208e22.png)

```python
letters = input().split()
n = int(input())
lst_let = []
for i in range(n):
    res = letters[i::n]
    lst_let.append(res)
print(lst_let)
```

6. На вход программе подается натуральное число `n≥1`. Напишите программу, которая выводит первые `n` строк треугольника Паскаля.

**Формат выходных данных**

Программа должна вывести первые `n` строк треугольника Паскаля, каждую на отдельной строке в соответствии с образцом.

`n = 4`

```
1
1 1
1 2 1
1 3 3 1
```

```python
n = int(input())
triangle_pascal = []
for i in range(1, n + 1):
    triangle_pascal.append([1] * i)
    
for i in range(n):
    for j in range(1, len(triangle_pascal[i]) - 1):
        triangle_pascal[i][j] = triangle_pascal[i - 1][j - 1] + triangle_pascal[i - 1][j]
        
for row in triangle_pascal:
    print(*row)
```








## 32.Матрицы

Матрицы(частный случай **вложенных списков**) — таблицы, заполненные какими-то значениями, обычно числами.

![image](https://user-images.githubusercontent.com/124737857/230144704-f9c80c89-dd51-4ba6-9119-401fe2a47d99.png)

Для работы с матрицами нужно уметь получать элемент `i`-й строки `j`-го столбца. Для этого обычно заводят список строк матрицы, где каждая строка — список элементов.
Получается вложенный список или список списков. Теперь, чтобы получить определенный элемент, достаточно из списка строк матрицы выбрать `i`-ю и взять `j`-й элемент
этой строки.

```python
matrix  = [[2, -5, -11, 0],
           [-9, 4, 6, 13],
           [4, 7, 12, -2]]

print(matrix[1][2])  # вывод элемента на позиции (2, 3)
```

<h3 align="center">Перебор элементов матрицы</h3>

Чтобы перебрать элементы матрицы, необходимо использовать **вложенные циклы**. Например, выведем на экран все элементы матрицы, **перебирая их по строкам**:

```python
rows, cols = 3, 4           # rows - количество строк, cols - количество столбцов

matrix  = [[2, 3, 1, 0],
           [9, 4, 6, 8],
           [4, 7, 2, 7]]

for r in range(rows):
    for c in range(cols):
        print(matrix[r][c], end=' ')
    print()
```    
  
Результатом работы такого кода будет:

```
2 3 1 0 
9 4 6 8 
4 7 2 7 
```

<h3 align="center">Выравнивание матрицы</h3>

Рассмотрим программный код:

```python
rows, cols = 3, 4                # rows - количество строк, cols - количество столбцов

matrix  = [[277, -930, 11, 0],
           [9, 43, 6, 87],
           [4456, 8, 290, 7]]

for r in range(rows):
    for c in range(cols):
        print(matrix[r][c], end=' ')
    print()
```    

Результатом работы такого кода будет:

```
277 -930 11 0 
9 43 6 87 
4456 8 290 7 
```

Выведенная матрица не сильно похожа на упорядоченный прямоугольник. Элементы матрицы имеют разное количество разрядов и результат вывода получается смазанным.
Для решения проблемы удобно использовать строковые методы `ljust()` и `rjust()`.

Применив метод `ljust()` для выравнивания столбцов при выводе таблицы мы получим следующий код:

```python
rows, cols = 3, 4                # rows - количество строк, cols - количество столбцов

matrix  = [[277, -930, 11, 0],
           [9, 43, 6, 87],
           [4456, 8, 290, 7]]

for r in range(rows):
    for c in range(cols):
        print(str(matrix[r][c]).ljust(6), end='')
    print()
```    
    
Результатом выполнения такого кода будет:

```
277   -930  11    0     
9     43    6     87    
4456  8     290   7 
```

<h3 align="center">Квадратные матрицы</h3>

Матрица с одинаковым количеством строк и столбцов называется **квадратной**. У квадратной матрицы есть две диагонали:

 - **главная**: проходит из верхнего левого в правый нижний угол матрицы;
 - **побочная**: проходит из нижнего левого в правый верхний угол матрицы.
 
![image](https://user-images.githubusercontent.com/124737857/230145977-0e9949a7-915a-4e77-83e2-01f568e391d0.png)

Элементы с равными индексами `i == j` находятся на **главной диагонали**. Такие элементы обозначаются `matrix[i][i]`.

Элементы с индексами `i` и `j`, связанными соотношением `i + j + 1 = n` (или `j = n - i - 1`), где `n` — размерность матрицы, находятся на **побочной диагонали**.

Таким образом, чтобы установить элементы главной или побочной диагонали, достаточно одного цикла.

Результатом выполнения следующего кода:

```python
n = 8
matrix = [[0]*n for _ in range(n)]    # создаем квадратную матрицу размером 8×8

for i in range(n):                     # заполняем главную диагональ единицами, а побочную двойками
    matrix[i][i] = 1
    matrix[i][n-i-1] = 2

for r in range(n):                     # выводим матрицу
    for c in range(n):
        print(matrix[r][c], end=' ')
    print()
```    
    
будет:

```
1 0 0 0 0 0 0 2 
0 1 0 0 0 0 2 0 
0 0 1 0 0 2 0 0 
0 0 0 1 2 0 0 0 
0 0 0 2 1 0 0 0 
0 0 2 0 0 1 0 0 
0 2 0 0 0 0 1 0 
2 0 0 0 0 0 0 1 
```

Заметим также, что:

 - если элемент находится выше главной диагонали, то `i < j`, если ниже, `i > j`.
 - если элемент находится выше побочной диагонали, то `i + j + 1 < n`, если ниже, `i + j + 1 > n`.

Чтобы понять, в какой области лежит элемент можно воспользоваться следующей картинкой.

![image](https://user-images.githubusercontent.com/124737857/230146661-11a58b9e-95f9-4b30-807d-f1d356193db8.png)

## Задания

1. Напишите программу, которая выводит максимальный элемент в заштрихованной области квадратной матрицы.

![image](https://user-images.githubusercontent.com/124737857/230147548-b6d1e4da-c2e0-4e24-ac92-83b0981514bd.png)

```python
n = int(input())
matrix = []
for _ in range(n):
    row = [int(i) for i in input().split()]
    matrix.append(row)

mx = matrix[0][0]    
for i in range(n):
    for j in range(n):
        if (i >= j and i <= n - 1 - j) or (i <= j and i >= n - 1 - j):
            if mx < matrix[i][j]:
                mx = matrix[i][j]
print(mx)
```

2. Напишите программу, которая проверяет симметричность квадратной матрицы относительно главной диагонали.

```python
N = int(input())
matrix = []
for _ in range(N):
    matrix.append(list(map(int, input().split())))
    
for i in range(1, N):
    for j in range(i):
        flag = False
        if matrix[i][j] != matrix[j][i]:
            flag = True
            break
    if flag:
        print("NO")
        break
else:
    print("YES")
```

3. На шахматной доске 8×8 стоит конь. Напишите программу, которая отмечает положение коня на доске и все клетки, которые бьет конь. Клетку, где стоит конь, отметьте
английской буквой `N`, клетки, которые бьет конь, отметьте символами `*`, остальные клетки заполните точками.

**Формат входных данных**

На вход программе подаются координаты коня на шахматной доске в шахматной нотации (то есть в виде e4, где сначала записывается номер столбца (буква от a до h, слева
направо), затем номеру строки (цифра от 1 до 8, снизу вверх)).

**Примечание**. Шахматная доска имеет вид:

![image](https://user-images.githubusercontent.com/124737857/230149118-2a9b1ff8-eef4-4405-b91c-abea2ce0ee81.png)

```python
matrix = [["."] * 8 for i in range(8)]
x, y = input()
i_X = 8 - int(y)
i_Y = (ord(x) - ord("a"))
matrix[i_X][i_Y] = "N"
step = ((-1, -2), (-2, -1), (-1, 2), (-2, 1), (1, -2), (2, -1), (1, 2), (2, 1))

for x, y in step:
    if 0 <= i_X + x <= 7 and 0 <= i_Y + y <= 7:
        matrix[i_X + x][i_Y + y] = "*"

for row in matrix:
    print(*row)
```

4. Магическим квадратом порядка `n` называется квадратная таблица размера `n×n`, составленная из всех чисел 1,2,3,…,n^2
так, что суммы по каждому столбцу, каждой строке и каждой из двух диагоналей равны между собой. Напишите программу, которая 
проверяет, является ли заданная квадратная матрица магическим квадратом.

```python
n = int(input())
matrix = [[int(j) for j in input().split()] for i in range(n)]

magic = n * (n ** 2 + 1) // 2
trace = 0
trace_2 = 0
flag = True

for i, row in enumerate(matrix):
    rows = sum(row)
    trace += row[i]
    trace_2 += row[~i]
    if rows != magic:
        flag = False
        break
        
for row in zip(*matrix):
    colums = sum(row)
    if colums != magic:
        flag = False
        break
        
flag = True if flag and trace == trace_2 == magic else False        
sequence = [el for row in matrix for el in row]

print(("NO", "YES")[flag and sorted(sequence) == list(range(1, n ** 2 + 1))])    
```    

5. На шахматной доске 8×8 стоит ферзь. Отметьте положение ферзя на доске и все клетки, которые бьет ферзь. Клетку, где стоит ферзь, отметьте буквой Q, клетки,
которые бьет ферзь, отметьте символами `*`, остальные клетки заполните точками.

**Формат входных данных**

На вход программе подаются координаты ферзя на шахматной доске в шахматной нотации (то есть в виде e4, где сначала записывается номер столбца (буква от a до h,
слева направо), затем номер строки (цифра от 1 до 8, снизу вверх)).

```python
matrix = [['.'] * 8 for n in range(8)]
a = input()
x = 8 - int(a[1])
y = ord(a[0]) - ord('a')
matrix[x][y] = 'Q'

for i in range(8):
    for j in range(8):
        if (x == i or y == j or abs(x - i) == abs(y - j)) and (abs(x - i) != 0 or abs(y - j) != 0):
            matrix[i][j] = "*"

for row in matrix:
    print(*row)
```

6. На вход программе подаются два натуральных числа n и m. Напишите программу, которая создает матрицу размером n×m заполнив её в соответствии с образцом.

```
5 5
```

```
1 2 3 4 5
2 3 4 5 1
3 4 5 1 2
4 5 1 2 3
5 1 2 3 4
```

```python
n, m = map(int, input().split())
matrix = [[0] * m for _ in range(n)]

for i in range(n):
    for j in range(m):
        matrix[i][j] = ((i + j) % m) + 1

                
for row in matrix:
    for el in row:
        print(str(el).ljust(3), end="")
    print()
```

```python
# 2 способ
n, m = map(int, input().split())
matrix = [[0] * m for _ in range(n)]
res = list(range(1, m + 1))

for i in range(n):
    matrix[i][:] = res
    res = res[1:] + [res[0]]

for row in matrix:
    for el in row:
        print(str(el).ljust(3), end="")
    print()
```

7. На вход программе подаются два натуральных числа n и m. Напишите программу, которая создает матрицу размером n×m заполнив её "диагоналями" в соответствии с образцом.

```
3 5
```

```
1  2  4  7  10
3  5  8  11 13
6  9  12 14 15
```

```python
n, m = map(int, input().split())
matrix = [[0] * m for _ in range(n)]
cnt = 1

for c in range(n + m - 1):
    for i in range(n):
        for j in range(m):
            if i + j == c:
                matrix[i][j] = cnt
                cnt += 1
            if j >= c:
                break
        if i >= c:
            break

for row in matrix:
    for el in row:
        print(str(el).ljust(3), end="")
    print()
```

8. Первая строка содержит два целых числа `r` и `c` (`2 ≤ r`, `c ≤ 10`), обозначающих количество строк и количество столбцов в торте. 
Следующие `r` строк содержат по `c` символов — `j`-ый символ `i`-ой строки обозначает содержимое ячейки в строке `i` и столбце `j`, и имеет 
одно из следующих значений:

 - символ '.' обозначает ячейку торта без гадкой клубнички;
 - символ 'S' обозначает ячейку торта с гадкой клубничкой.

**Выходные данные**

Выведите максимальное количество ячеек торта, которые может съесть тортминатор.

```python
n, m = map(int, input().split())
matrix = [list(input()) for _ in range(n)]
cnt = 0
cnt_rows = 0
cnt_colums = 0

for row in matrix:
    if "S" not in row:
        cnt += len(row)
        cnt_rows += 1
        
for row in zip(*matrix):
    if "S" not in row:
        cnt += len(row)
        cnt_colums += 1
        
print(cnt - cnt_colums * cnt_rows)
```

9. Напишите программу, на вход которой подаётся прямоугольная матрица в виде последовательности строк. После последней строки
матрицы идёт строка, содержащая только строку "end". Программа должна вывести матрицу того же размера, у которой каждый элемент в позиции `i`, `j` равен сумме
элементов первой матрицы на позициях (`i-1`, `j`), (`i+1`, `j`), (`i`, `j-1`), (`i`, `j+1`). У крайних символов соседний элемент находится с противоположной
стороны матрицы. В случае одной строки/столбца элемент сам себе является соседом по соответствующему направлению.

```python
line = input()
matrix = []
while line != "end":
    matrix.append([int(i) for i in line.split()])
    line = input()
step = ((-1, 0), (0, -1), (0, 1), (1, 0))
res_matrix = []
n = len(matrix)

for i in range(n):
    m = len(matrix[i])
    row = []
    for j in range(m):
        s = 0
        for i_x, i_y in step:
            s += matrix[(i + i_x) % n][(j + i_y) % m]
        row.append(s)
    res_matrix.append(row)
    
for row in res_matrix:
    print(*row)
```

10. Поле игры сапер

На вход поступает размер поля и количество мин в одной строке, а далее `k` строк, координаты мин.
Необходимо мину изобразить `"*"`, поля возле которых нет мин `"."`, а поля возле которых есть мины заполнить цифрой, в 
зависимости от того сколько мин вокруг данной клетки

```python
n, m, count_mines = map(int, input().split())
matrix = [["."] * m for i in range(n)]
step = ((-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1))

for _ in range(count_mines):
    i, j = map(int, input().split())
    matrix[i - 1][j - 1] = "*"

    
for i in range(n):
    for j in range(m):
        cnt = 0
        if matrix[i][j] == ".":
            for i_x, i_y in step:
                if 0 <= i + i_x < n and 0 <= j + i_y < m:
                    if matrix[i + i_x][j + i_y] == "*":
                        cnt += 1
        if cnt > 0:
            matrix[i][j] = cnt
            
for row in matrix:
    print(*row, sep="")
```

11. Вводится двумерный список размерностью 5 х 5 элементов, состоящий из нулей и, в некоторых позициях, единиц. Требуется проверить, не касаются ли единицы
друг друга по горизонтали, вертикали и диагонали. То есть, вокруг каждой единицы должны быть нули. Если проверка проходит вывести ДА, иначе - НЕТ.

```python
matrix = [[int(i) for i in input().split()] for _ in range(5)]
step = ((-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1))

for i in range(5):
    for j in range(5):
        flag = False
        if matrix[i][j] == 1:
            for i_x, i_y in step:
                if 0 <= i + i_x < 5 and 0 <= j + i_y < 5:
                    if matrix[i + i_x][j + i_y] == 1:
                        flag = True
                        break
        if flag:
            break
    if flag:
        print("НЕТ")
        break
else:
    print("ДА")
```

#### 2 способ

Обходим матрицу с `0` до `n - 1` и проверяем по сумме каждого квадрата, если значение больше 1 прерываем цикл

![image](https://user-images.githubusercontent.com/124737857/230153578-eb65b3b6-54e4-4ffd-b283-a7a35fa78e7d.png)

```python
flag = False
for i in range(4):
    for j in range(4):
        if matrix[i][j] + matrix[i + 1][j] + matrix[i][j + 1] + matrix[i + 1][j + 1] > 1:
            flag = True
            break
    if flag:
        print('НЕТ')
        break
else:
    print('ДА')
```

12. На вход программе подаются два натуральных числа n и m. Напишите программу, которая создает матрицу размером n×m заполнив её "спиралью" в соответствии с образцом.

```
4 5
```

```
1  2  3  4  5
14 15 16 17 6
13 20 19 18 7
12 11 10 9  8
```

```python
n, m = map(int, input().split())
matrix = [[0] * m for _ in range(n)]

cnt = 0
shift = 0

while shift < min(n, m) // 2 + 1:
    
    if cnt < n * m:
        for i in range(shift, m - shift):
            cnt += 1
            matrix[shift][i] = cnt
            
    if cnt < n * m:
        cnt -= 1
        for i in range(shift, n - shift):
            cnt += 1
            matrix[i][-(1 + shift)] = cnt
            
    if cnt < n * m:
        cnt -= 1
        for i in range(m - 1 - shift, shift - 1, -1):
            cnt += 1
            matrix[-(1 + shift)][i] = cnt

    if cnt < n * m:
        cnt -= 1
        for i in range(n - 1 - shift, shift, -1):
            cnt += 1
            matrix[i][shift] = cnt

    shift += 1
      
for row in range(n):
    for column in range(m):
        print(str(matrix[row][column]).ljust(3), end="")
    print()
```

## 33.Вложенные циклы в list comprehensions и вложенные list comprehensions

<h3 align="center">Вложенные циклы</h3>

В списочном выражении можно использовать несколько операторов цикла for, кроме того после каждого цикла можно прописывать условие.

Общий вид конструкции:

```
[<способ формирования значения>
for <переменная_1> in <итерируемый объект> if <условие>
for <переменная_2> in <итерируемый объект> if <условие>
...
for <переменная_N> in <итерируемый объект> if <условие>
]
```

Следующий программный код:

```python
numbers = [i * j for i in range(1, 5) for j in range(2)]
print(numbers)  # [0, 1, 0, 2, 0, 3, 0, 4]
```

Такой код равнозначен следующему:

```python
numbers = []

for i in range(1, 5):
    for j in range(2):
        numbers.append(i * j)
print(numbers)        
```

Такие конструкции можно писать в несколько строк и при желании использовать после каждого цикла условия:

```python
res = [(i, j)
       for i in range(3) if i % 3 == 0
       for j in range(4) if j % 2 == 0 or j > 2
      ]
print(res)  # [(0, 0), (0, 2), (0, 3)]
```

<h3 align="center">Вложенные списочные выражения</h3>

В качестве `оператора` может выступать любая конструкция Python:

```
[<оператор> for <переменная> in <итерируемый объект>]
```

Например, другое списочное выражение, таким образом получаем вложенное списочное выражение:

```
[[списочное выражение]
  for <переменная> in <итерируемый объект>
]
```

Например, с помощью вложенного списочного выражения можно возвести все элементы матрицы в квадрат:

```python
A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
A = [[el ** 2 for el in row] for row in A]
print(A)  # [[1, 4, 9], [16, 25, 36], [49, 64, 81]]
```

<h3 align="center">Списочное выражение как итерируемый объект</h3>

Списочное выражение можно использовать в качестве итерируемого объекта:

```
[<способ формирования значений> for <переменная> in [списочное выражение]]
```

Например:

```python
g = [u ** 2 for u in [x + 1 for x in range(5)]]
print(g)  # [1, 4, 9, 16, 25]
```

## Задания

1. Вводится натуральное число `N`. С помощью `list comprehension` сформировать двумерный список размером `N x N`, состоящий из нулей, 
а по главной диагонали - единицы. (Главная диагональ - это элементы, идущие по диагонали от верхнего левого угла матрицы до ее
нижнего правого угла).

```python
N = int(input())
matrix = [[1 if i == j else 0 for j in range(N)] for i in range(N)]
for row in matrix:
    print(*row)
```

2. Вводится натуральное число `N`. Необходимо сгенерировать вложенный список с помощью `list comprehension`, размером `N x N`, где 
первая строка содержала бы все нули, вторая - все единицы, третья - все двойки и так до `N`-й строки.

```python
N = int(input())
matrix = [[i] * N for i in range(N)]
for row in matrix:
    print(*row)
```

3. Вводится двумерный список в виде таблицы целых чисел. С помощью `list comprehension` преобразовать двумерный
список в одномерный так, чтобы значения элементов шли в обратном порядке. Результат отобразить в виде строки из чисел, 
записанных через пробел.

```python
matrix = [[int(i) for i in input().split()] for i in range(N)]
res = [matrix[i][j] for i in range(len(matrix) - 1, -1, -1) for j in range(len(matrix[0]) - 1, -1, -1)]
print(*res)
```


4. Вводится список целых чисел в строку через пробел. С помощью `list comprehension` сформировать из них двумерный список `lst` 
размером `N x N` (квадратную таблицу чисел). Гарантируется, что из набора введенных чисел можно сформировать квадратную матрицу
(таблицу). Результат отобразить в виде списка командой

```python
lst = [int(i) for i in input().split()]
N = int(len(lst) ** 0.5)
matrix = [lst[i * N:(i + 1) * N] for i in range(N)]
print(matrix)
```
