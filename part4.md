## Содержание 
 - [20.Условный оператор if. Конструкция if-else](#20условный-оператор-if-конструкция-if-else)
 - [21.Вложенные и каскадные условные операторы](#21вложенные-и-каскадные-условные-операторы)
 - [22.Тернарный условный оператор](#22тернарный-условный-оператор)
 - [23.Конструкция match-case](#23конструкция-match-case)
 - [24.Оператор цикла while](#24оператор-цикла-while)
 - [25.Операторы break, continue, else](#25операторы-break-continue-else)
 - [26.Оператор цикла for и функция range](#26оператор-цикла-for-и-функция-range)
 - [27.Функция enumerate](#27функция-enumerate)


## 20.Условный оператор if. Конструкция if-else

Проверка условий и принятие решений по результатам этой проверки называется ветвлением (branching). Программа таким способом выбирает, по какой из возможных ветвей
ей двигаться дальше.

В Python проверка условия осуществляется при помощи ключевого слова `if`.

```python
answer = input('Какой язык программирования мы изучаем?')
if answer == 'python':
    print('Верно! Мы изучаем python')
```    
    
Программа просит пользователя ввести текст и проверяет результат ввода. Если введенный текст равен строке `python`, то выводит пользователю текст:

```
Верно! Мы изучаем python
```

Двоеточие (:) в конце строки с инструкцией `if` сообщает интерпретатору Python, что дальше находится блок команд. В блок команд входят все строки с отступом
под строкой с инструкцией `if`, вплоть до следующей строки без отступа.

Предыдущая программа выводит текст в случае, если условие истинно. Но если условие ложно, то программа ничего не выводит. Для того, чтобы обеспечить возможность
выполнять что-либо, если условие оказалось ложным, мы используем ключевое слово `else`.

```python
answer = input('Какой язык программирования мы изучаем?')
if answer == 'python':
    print('Верно! Мы изучаем python')
else:
    print('Не совсем так!')
```

**Отступ** — небольшое смещение строки кода вправо. По соглашению PEP 8, для отступа блоков кода используются 4 пробела.

<h3 align="center">Операторы сравнения</h3>

В условном операторе `if` можно использовать все 6 операций сравнения, расмотренных ранее.

<h3 align="center">Цепочки сравнений</h3>

Операторы сравнения в Python можно объединять в цепочки (в отличии от большинства других языков программирования, где для этого нужно использовать логические связки),
например, `a == b == c` или `1 <= x <= 10`.

<h3 align="center">Логические операторы</h3>
    
В Python есть три логических оператора, которые позволяют создавать сложные условия:

- **and** — логическое умножение;
- **or** — логическое сложение;
- **not** — логическое отрицание.

<h3 align="center">Оператор and</h3>

Оператор `and` может объединять произвольное количество условий:

```python
if a > 2 and a < 10:
    print("(2; 10)")
```

Таблица истинности для оператора `and`.

| a | b | a and b |
|---|---|---------|
| False | False | False |
| False | True | False |
| True | False | False |
| True | True | True |

Как показывает таблица, чтобы значение выражения с оператором `and` было истинным, должны быть истинными **все** объединенные им условия.

<h3 align="center">Оператор or</h3>

Таблица истинности для оператора `or`.

| a | b | a or b |
|---|---|---------|
| False | False | False |
| False | True | True |
| True | False | True |
| True | True | True |

Для того, чтобы выражение `or` было истинным, требуется, чтобы **хотя бы одно** условие оператора `or` было истинным. 

<h3 align="center">Оператор not</h3>

Оператор `not` позволяет инвертировать результат логического выражения.

Таблица истинности для оператора `not`:

| a | not a |
|---|------|
| False | True |
| True | False |

<h3 align="center">Приоритеты логических операторов</h3>

Можно совмещать логические операторы.

Логические операторы, подобно арифметическим операторам (`+`, `-`, `*`, `/`), имеют приоритет выполнения. Приоритет выполнения следующий:

 - в первую очередь выполняется логическое отрицание `not`;
 - далее выполняется логическое умножение `and`;
 - далее выполняется логическое сложение `or`.
  
Для **явного указания порядка** выполнения условных операторов **используют скобки**.

<h3 align="center">Примечания</h3>

**Примечание**. Оба оператора, `and` и `or`, вычисляются по **укороченной схеме**.

Вот как это работает с оператором `and`. Если условие слева от оператора `and` является ложным, то условие справа от него не проверяется.

Аналогично работает оператор `or`. Если условие слева от оператора `or` истинное, то условие справа от него не проверяется.

### Задания:

1. Вводятся четыре целых числа a, b, c, d в одну строку через пробел. Определить, войдет ли в конверт с внутренними размерами 
a и b мм прямоугольная открытка с размерами с и d мм. Для размещения открытки в конверте необходим зазор в 1 мм с каждой 
стороны. Открытку можно поворачивать на 90 градусов. Вывести ДА, если входит и НЕТ - если не входит.

```python
a, b, c, d = map(int, input().split())
if max(a, b) > max(c, d) + 1 and min(a, b) > min(c, d) + 1:
    print('ДА')
else:
    print('НЕТ')
```

2. Даны две различные клетки шахматной доски. Напишите программу, которая определяет, может ли ладья попасть с первой клетки 
на вторую одним ходом. Программа получает на вход четыре числа от 1 до 8 каждое, задающие номер столбца и номер строки 
сначала для первой клетки, потом для второй клетки. Программа должна вывести «YES», если из первой клетки ходом ладьи можно 
попасть во вторую, или «NO» в противном случае.

```python
x1, y1 = int(input()), int(input())
x2, y2 = int(input()), int(input())
if (x1 == x2 or y1 == y2) and (x2 != x1 or y2 != y1):
    print('YES')
else:
    print('NO')
```

3. Даны две различные клетки шахматной доски. Напишите программу, которая определяет, может ли король попасть с первой 
клетки на вторую одним ходом. Программа получает на вход четыре числа от 1 до 8 каждое, задающие номер столбца и номер
строки сначала для первой клетки, потом для второй клетки. Программа должна вывести «YES», если из первой клетки ходом
короля можно попасть во вторую, или «NO» в противном случае.


```python
# Используя теорему Пифагора
x1, y1 = int(input()), int(input())
x2, y2 = int(input()), int(input())
if 1 <= (x1 - x2) ** 2 <= 2 and 1 <= (y1 - y2) ** 2 <= 2:
     print('YES')
else:
    print('NO')
```

4. Напишите программу, которая на вход получает координаты двух клеток шахматной доски и выводит сообщение о том, являются 
ли эти клетки одного цвета. Столбцы на шахматной доске обозначаются английскими строчными буквами.
Программа должна выводить YES, когда клетки одного цвета, NO - разного. Гарантируется, что значение колонок это латинские буквы
abcdefgh, а строки это символы цифр от 1-8

```python
coord_x1, coord_y1 = input()
coord_x2, coord_y2 = input()
if (ord(coord_x1) - ord("a") + 1 + int(coord_y1)) % 2 == 0:
    res_1 = "black"
else:
    res_1 = "white"
if (ord(coord_x2) - ord("a") + 1 + int(coord_y2)) % 2 == 0:
    res_2 = "black"
else:
    res_2 = "white"
if res_1 == res_2:
    print("YES")
else:
    print("NO")
```

5. Даны две различные клетки шахматной доски. Напишите программу, которая определяет, может ли слон попасть с первой клетки 
на вторую одним ходом. Программа получает на вход четыре числа от 1 до 8 каждое, задающие номер столбца и номер строки 
сначала для первой клетки, потом для второй клетки. Программа должна вывести «YES», если из первой клетки ходом слона можно 
попасть во вторую или «NO» в противном случае.

```python
x1, y1 = int(input()), int(input())
x2, y2 = int(input()), int(input())
if abs(x1 - x2) == abs(y1 - y2) and abs(x1 - x2) != 0:
    print("YES")
else:
    print("NO")
```

6. Даны две различные клетки шахматной доски. Напишите программу,  которая определяет, может ли конь попасть с первой клетки
на вторую одним ходом. Программа получает на вход четыре числа от 1 до 8 каждое, задающие номер столбца и номер строки 
сначала для первой клетки, потом для второй клетки. Программа должна вывести «YES», если из первой клетки ходом коня можно
попасть во вторую или «NO» в противном случае.

```python
x1, y1 = int(input()),int(input())
x2, y2 = int(input()),int(input())
if (abs(x2 - x1) == 1 and abs(y2 - y1) == 2) or (abs(x2 - x1) == 2 and abs(y2 - y1) == 1):
    print('YES')
else:
    print('NO')
```

7. Даны две различные клетки шахматной доски. Напишите программу, которая определяет, может ли ферзь попасть с 
первой клетки на вторую одним ходом. Программа получает на вход четыре числа от 1 до 8 каждое, задающие номер столбца и 
номер строки сначала для первой клетки, потом для второй клетки. Программа должна вывести «YES», если из первой клетки ходом 
ферзя можно попасть во вторую или «NO» в противном случае.

```python
x1, y1 = int(input()),int(input())
x2, y2 = int(input()),int(input())
if ((x1 == x2 or y1 == y2) or abs(x2 - x1) == abs(y2 - y1)) and (abs(x2 - x1) != 0 or abs(y2 - y1) != 0):
    print('YES')
else:
    print('NO')
```

## 21.Вложенные и каскадные условные операторы

<h3 align="center">Вложенный оператор</h3>

Внутри условного оператора можно использовать любые инструкции языка Python, в том числе и условный оператор. Получаем вложенное ветвление: после одной развилки
в ходе исполнения программы появляется другая развилка. При этом вложенные блоки имеют больший размер отступа (+4 пробела для каждого следующего уровня).

```python
if условие1:
    блок кода
else:
    if условие2:
        блок кода
    else:
        if условие3:
            блок кода            
        ...
```

При данном подходе вложенность становится большой, код становится трудно понять. Стоит избегать глубокого вложения. Для этого в Python есть **каскадный условный
оператор**.

<h3 align="center">Каскадный условный оператор</h3>

Синтаксис каскадного условного оператора имеет следующий вид:

```python
if условие1:
    блок кода
elif условие2:
    блок кода
...
else:
    блок кода
```

При исполнении такого условного оператора сначала проверяется условие 1. Если оно является истинным, то исполняется блок кода, который следует сразу после него,
вплоть до выражения `elif`. Остальная часть конструкции игнорируется. Однако если условие 1 является ложным, то программа перескакивает непосредственно к 
следующему выражению `elif` и проверяет условие 2. Если оно истинное, то исполняется блок кода, который следует сразу после него, вплоть до следующего 
выражения `elif`. И остальная часть условного оператора тогда игнорируется. Этот процесс продолжается до тех пор, пока не будет найдено условие, которое является
истинным, либо пока больше не останется выражений `elif`. Если ни одно условие не является истинным, то исполняется блок кода после выражения `else`.

> Заключительный блок `else` в операторе `if-elif-else` необязательный

### Задания

1. Ваша программа получает на вход возраст человека. Вам необходимо вывести на экран сообщение:

 - "Младенец", если возраст меньше 2х лет;
 - "Малыш", если возраст от 2, но меньше 4;
 - "Ребенок", если возраст от 4 лет, но меньше 12;
 - "Подросток", когда возраст от 12 лет, но меньше 19;
 - "Взрослый человек", когда возраст от 19 лет, но меньше 65;
 - "Пожилой человек", если возраст 65 и более.


```python
age = int(input())
if age < 2:
    print('Младенец')
elif 2 <= age < 4:
    print('Малыш')
elif 4 <= age < 12:
    print('Ребенок')
elif 12 <= age < 19:
    print('Подросток')
elif 19 <= age < 65:
    print('Взрослый человек')
else:
    print('Пожилой человек')
```

2. Напишите программу, которая считывает с клавиатуры два целых числа и строку. Если эта строка является обозначением 
одной из четырёх математических операций (`+`, `-`, `*`, `/`), то выведите результат применения этой операции к введённым ранее 
числам, в противном случае выведите `Неверная операция`. Если пользователь захочет поделить на ноль, выведите текст 
`На ноль делить нельзя!`.

```python
a, b = int(input()), int(input())
operation = input()
if operation == '+':
    print(a + b)
elif operation == '-':
    print(a - b)
elif operation == '*':
    print(a * b)
elif operation == '/':
    if b != 0:
        print(a / b)
    else:
        print('На ноль делить нельзя!')
else:
    print('Неверная операция')
```

3. Жители страны Малевии часто экспериментируют с планировкой комнат. Комнаты бывают треугольные, прямоугольные и круглые. 
Чтобы быстро вычислять жилплощадь, требуется написать программу, на вход которой подаётся тип фигуры комнаты и соответствующие
параметры, которая бы выводила площадь получившейся комнаты.
Для числа π в стране Малевии используют значение 3.14.

```python
figure = input()
if figure == 'треугольник':
    a, b, c = int(input()), int(input()), int(input())
    p = (a + b + c) / 2
    print((p * (p - a) * (p - b) * (p - c)) ** 0.5)
elif figure == 'прямоугольник':
    a, b = int(input()), int(input())
    print(a * b)
else:
    r = int(input())
    print(3.14 * r ** 2)
```

4. Напишите программу, считывающую с пользовательского ввода целое число n (неотрицательное), выводящее это число в 
консоль вместе с правильным образом изменённым словом "программист", для того, чтобы робот мог нормально общаться с 
людьми, например: 1 программист, 2 программиста, 5 программистов. В комнате может быть очень много программистов. Проверьте, что ваша программа правильно 
обработает все случаи, как минимум до 1000 человек.

```python
number = int(input())
if number % 10 == 1 and number % 100 != 11:
    print(number, 'программист')
elif number % 10 in (2, 3, 4) and number % 100 not in (12, 13, 14):
    print(number, 'программиста')
else:
    print(number, 'программистов')
```

5. Ваша программа должна считать одно натуральное число, после чего вывести:

 - “Fizz”, если это число делится на 3;
 - “Buzz”, если это число делится на 5;
 - “FizzBuzz”, если выполнены оба предыдущих условия;
 - само это число в остальных случаях."""

```python
a = int(input())
s = ''
if a % 3 == 0:
    s += "Fizz"
if a % 5 == 0:
    s += 'Buzz'
if not s:
    s += str(a)
print(s)
```

6. Цвета колеса рулетки
На колесе рулетки карманы пронумерованы от 0 до 36. Ниже приведены цвета карманов: 

 - карман 0 зеленый;
 - для карманов с 1 по 10 карманы с нечетным номером имеют красный цвет, карманы с четным номером – черный;
 - для карманов с 11 по 18 карманы с нечетным номером имеют черный цвет, карманы с четным номером – красный;
 - для карманов с 19 по 28 карманы с нечетным номером имеют красный цвет, карманы с четным номером – черный;
 - для карманов с 29 по 36 карманы с нечетным номером имеют черный цвет, карманы с четным номером – красный.
Напишите программу, которая считывает номер кармана и показывает, является ли этот карман зеленым, красным или черным. 
Программа должна вывести сообщение об ошибке, если пользователь вводит число, которое лежит вне диапазона от 0 до 36.

```python
n = int(input())
if 0 <= n <= 36:
    if n == 0:
        print("зеленый")
    elif ((1 <= n <= 10 or 19 <= n <= 28) and n % 2 == 1) or ((11 <= n <= 18 or 29 <= n <= 36) and n % 2 == 0):
        print("красный")
    else:
        print("черный")
else:
    print("ошибка ввода")
```

7. Пересечение отрезков
На числовой прямой даны два отрезка:[a1; b1] и [a2; b2]. Напишите программу, которая находит их пересечение.

Пересечением двух отрезков может быть:

- отрезок;
- точка;
- пустое множество.

Все варианты пересечения:

![image](https://user-images.githubusercontent.com/124737857/229292441-cd7dabcf-abf4-4b42-96bf-eaa11e846405.png)

```python
a1, b1 = int(input()),int(input())
a2, b2 = int(input()),int(input())
if a1 > b2 or a2 > b1:
    print('пустое множество')
elif b1 == a2 or b2 == a1:
    print(min(b1, b2))
elif a1 >= a2 and b1 <= b2:
    print(a1, b1)
elif a2 >= a1 and b2 <= b1:
    print(a2, b2)
else:
    print(max(a1, a2), min(b1, b2))
```    

## 22.Тернарный условный оператор

**Тернарный оператор** — это способ написания условных конструкций. 

Тернарный оператор состоит из трех операндов, которые помогут написать условную конструкцию `if-else` немного другим способом, более коротким.

Три операнда тернарного оператора:

 - `condition` логическое выражение, которое может принимать истинное или ложное значение
 - `true_value` значение, которое будет присвоено, если condition приняло истинное значение
 - `false_value` значение, которое будет присвоено, если condition приняло ложное значение

Записывается тернарный оператор по следующему шаблону:

```
true_value if condition else false_value
```

Альтернативная форма тернарного оператора в Python имеет вид:

```
(false_value, true_value)[condition]
```

<h4 align="center">Пример использования тернарного оператора</h4>

Реализация функции abs:

```python
x = x if x > 0 else -x
```

<h4 align="center">Отличие тернарного оператора от блока if-else</h4>

**Основные отличия**

 1. Тернарный оператор возвращает результат(его результат можно присвоить переменной),тогда как обычный условный оператор выполняет блок кода по определенному условию
и ничего не возвращает.

 2. В тернарном операторе нет внутренних блоков, поэтому вместо true_value и false_value можно прописывать какую-то одну инструкцию ЯП Python(часто это некое значение 
или результат работы арифметических операторов)

Вообще, тернарный оператор можно рассматривать как некий активный объект который возвращает некоторое значение в зависимости от условия

![image](https://user-images.githubusercontent.com/124737857/229306269-d22db275-793f-489a-b21f-2be42df3528c.png)

Поэтому его можно использовать например при конкатенации строк:

```python
a = 12
print("a - " + ("четное" if a % 2 == 0 else "нечетное") + " число")
```

При этом круглые скобки необходимы(у тернарника самый низкий приоритет из всех операторов). Ниже приоритет только у распаковки(`*`) , но это лишь потому, что 
звездочка, на самом деле, оператором не является, это отдельная конструкция языка, которая выполняется по окончанию вычисления всего выражения справа!

Так как можно влаживать в тернарный оператор любые конструкции, можно вложить тернарный оператор внутрь другого. Однако такие конструкции редко встречаются и их стоит избегать

## Задания

1. Ваша программа принимает на вход предложение и ваша задача определить является ли оно вопросом?
Если последний символ предложения это знак ?, то в переменную sentence сохраните строку Вопросительное, иначе запишите 
строку Обычное.

```python
res = "Вопросительное" if input()[-1] == "?" else "Обычное"
print(res)
```

2. Имеется список базовых нот:

```
m = ['до', 'ре', 'ми', 'фа', 'соль', 'ля', 'си']
```

Вводятся три целых числа в диапазоне от 1 до 7 - номера нот, в одну строчку через пробел. Необходимо отобразить указанные 
ноты в виде строки через пробел, но перед нотами до и фа дополнительно ставить символ диеза '#'. Реализовать эту программу 
с использованием тернарного условного оператора 

```python
m = ['до', 'ре', 'ми', 'фа', 'соль', 'ля', 'си']

a, b, c = map(int, input().split())
res1 = (f'#{m[a - 1]}' if m[a - 1] in ('до', 'фа') else m[a - 1])
res2 = (f'#{m[b - 1]}' if m[b - 1] in ('до', 'фа') else m[b - 1])
res3 = (f'#{m[c - 1]}' if m[c - 1] in ('до', 'фа') else m[c - 1])
print(res1, res2, res3)
```

## 23.Конструкция match-case

<h3 align="center">Оператор match-case</h3>

Оператор `match-case` появился только начиная с версии python 3.10. Называется оператором сопоставления с шаблонами (`pattern matching statement`).

Оператор `match-case` имеет следующий синтаксис(обязательно должен присутствовать хотя б один блок `case`):

```python
match <переменная>:
    case <шаблон_1>:
        операторы
    ...
    case <шаблон_n>:
        операторы
    case _:
        иначе(default)
```

После ключевого слова `match` указывается значение, которое нужно проверить на соответствие шаблону. В блоках `case` указываются сами шаблоны и проверка 
осуществляется сверху вниз, пока не найдется совпадение. Обычно в самом низу ставят блок действий по умолчанию, он выполняется в том случае, когда не найдется ни
один из шаблонов.

Например:

```python
number = int(input())

match number:
    case 0:
        print("zero")
    case 1:
        print("one")
    case 2:
        print("two")
    case _:
        print("Nothing")
```

Вместо `_` в блоке по умолчанию можно написать любую переменную(она будет создана в момент выполнения `match-case`):

```python
cmd = "top"

match cmd:
    case command:
        print(f"Команда - {command}")
```

<h3 align="center">Сравнение на несколько значений в операторе match-case</h3>

Для того, чтобы сравнить на несколько значений в одном блоке `case`, необходимо перечислить значения при помощи оператора `|`:

```python
number = int(input())

match number:
    case 0 | 1 | 2:
        print("zero or one or two")
    case _:
        print("Nothing")
```

<h3 align="center">Проверка типов при помощи оператора match-case</h3>

C помощью `match-case` можно проверить переменную `value` на принадлежность к определенному типу:

```python
value = 1234

match value:
    case str():
        print("str")
    case int():
        print("int")
    case list():
        print("list")
```

Можно не только проверить, что переменная какой-то тип данных, но и сформировать переменную.

```python
value = 1234

match value:
    case str() as var:
        print(var)
    case int():
        print("int")
```

При этом переменная создается только в том случае, если выполнено условие совпадения типа данных.

Можно дополнительно добавлять условия для переменных:

```python
number = 3

match number:
    case str() as var:
        print(var)
    case int() as var if 0 <= var < 10:
        print("int [0;9]")
```

Можно усложнить проверяя несколько типов данных:

```python
number = 3.4

match number:
    case str() as var:
        print(var)
    case int() | float() as var if 0 <= var <= 9:
        print("int or float [0;9]")
```

<h3 align="center">Примечание</h3>

**Примечание 1** [Документация по match-case](https://peps.python.org/pep-0622/)

## 24.Оператор цикла while

<h3 align="center">Цикл while</h3>

Cуществуют две основные разновидности цикла:

- циклы, повторяющиеся определенное количество раз (`for`, счетные циклы, **counting loops**);
- циклы, повторяющиеся до наступления определенного события (`while`, условные циклы, **conditional loops**)

Цикл `for` замечательно работает, если мы заранее знаем, сколько повторений (итераций) нам потребуется сделать. Но иногда нужно, чтобы цикл выполнялся до наступления
некоторого события, и количество итераций в этом случае заранее оценить просто невозможно. И здесь на помощь приходит цикл `while`.

Структура цикла `while` в Python выглядит так:

```
while условие:
    блок кода
```

Блок команд, который выполняется в цикле `while`, называется **телом цикла**, а условие выхода из цикла - **заголовком цикла**. Однократное выполнение тела цикла
называется **итерацией** цикла.

Рассмотрим код, использующий цикл `while`, который распечатает 10 раз слово Привет:

```python
i = 0

while i < 10:
    i += 1
    print("Привет")
```

<h3 align="center">Считывание данных до стоп значения</h3>

Часто при решении задач на цикл `while`, считываем данные, до тех пор пока пользователь не введет некоторое значение, которое называют **стоп значением**.

Напишем программу, которая считывает числа и выводит их квадраты, пока не будет введено -1.

```python
num = int(input())

while num != -1:
    print(num ** 2)
    num = int(input())
```    

Важными являются два момента:

 1. правильная инициализация переменной `num`;
 2. изменение переменной `num` внутри цикла `while`.

> Если не изменять переменную num внутри цикла, то он будет бесконечным.

<h3 align="center">Бесконечный цикл</h3>

Всегда, кроме редких случаев, цикл `while` должен содержать возможность завершиться. Если цикл не имеет возможности завершиться, то он называется **бесконечным
циклом**. Бесконечный цикл продолжает повторяться до тех пор, пока программа не будет прервана. В большинстве случаев следует избегать применения бесконечных циклов.

Пример бесконечного цикла:

```python
i = 0
total = 0
while i < 10:
    total += i
```

Так как в теле цикла не происходит изменения переменной `i`, то условие `i < 10` остается истинным и цикл выполняется бесконечно много раз.

Бесконечные циклы можно использовать в связке с оператором прерывания `break`.

## Задания

1. Вводится строка (слаг). Замените в этой строке все подряд идущие дефисы (--, ---, ---- и т.д.) на одинарные (-). Результат 
преобразования строки выведите на экран. Программу реализовать при помощи цикла while.

```python
s = input()
while s.count("--"):
    s = s.replace("--", "-")
print(s)
```

2. Всем известно, что ведьмак способен одолеть любых чудовищ, однако его услуги обойдутся недешево, к тому же ведьмак не
принимает купюры, он принимает только чеканные монеты. В мире ведьмака существуют монеты с номиналами 1,5,10,25.
Напишите программу, которая определяет какое минимальное количество чеканных монет нужно заплатить ведьмаку.

```python
cnt = 0
number = int(input())
while number >= 5:
    if number >= 25:
        number -= 25
        cnt += 1
    elif number >= 10:
        number -= 10
        cnt += 1
    elif number >= 5:
        number -= 5
        cnt += 1
print(cnt + number)
```

3. У Васи есть n пар носков. Утром каждого дня, собираясь в школу, Вася должен надеть пару носков. Вечером, прийдя со школы, 
Вася снимает надетые носки и выбрасывает их. Каждый m-й день (в дни с номерами m, 2m, 3m, ...) мама покупает Васе одну пару 
носков. Она делает это поздно вечером, поэтому Вася может надеть новые носки не раньше следующего дня. На сколько подряд 
идущих дней Васе хватит носков?

```python
n, m = map(int,input().split())
days = 0
while n:
    n -= 1
    days += 1
    if days % m == 0:
        n += 1
print(days)
```

4. Число n – вместимость рюкзака. Далее идут произвольное количество строк – объем очередного предмета.

**Выходные данные**

Строка "Довольно!" и затем два числа – суммарный объем упакованных товаров и их количество. Каждое значение выводится в 
отдельной строке.

```python
n, lst, s = int(input()), [], int(input())
while n - s >= 0:
    lst.append(s)
    n -= s
    s = int(input())
print("Довольно!", sum(lst), len(lst), sep="\n")
```

5. Ване на день рождения подарили n кубиков. Он с друзьями решил построить из них пирамиду. Ваня хочет построить пирамиду 
следующим образом: на верхушке пирамиды должен находиться 1 кубик, на втором уровне — 1 + 2 = 3 кубика, на третьем — 
1 + 2 + 3 = 6 кубиков, и так далее. Таким образом, на i-м уровне пирамиды должно располагаться 1 + 2 + ... + (i - 1) + i 
кубиков.
Ваня хочет узнать, пирамиду какой максимальной высоты он может создать с использованием имеющихся кубиков.

```python
n = int(input())
level = 0 # уровень пирамиды
cubes = 1 # количество кубиков для 1-го уровня 
while n >= cubes: # проверяем хватит ли кубиков для построения следующего уровня
    n -= cubes  # Вычитаем кубики из общего количества
    level += 1    # Если хватило, то увеличим уровень на 1
    cubes += level + 1 # подсчитываем сколько кубиков необходимо для следующего уровня

print(level)
```

6. Напишите программу, которая считывает с консоли числа (по одному в строке) до тех пор, пока сумма введённых чисел не будет 
равна 0 и сразу после этого выводит сумму квадратов всех считанных чисел. Гарантируется, что в какой-то момент сумма введённых чисел окажется равной 0, после
этого считывание продолжать не нужно.

```python
s = int(input())
total = s ** 2
while s:
    number = int(input())
    s += number
    total += number ** 2
print(total)
```

7. Последовательность Фибоначчи образуется так: первые два числа равны 1 и 1, а каждое последующее равно сумме двух 
предыдущих. Имеем такую последовательность чисел: 1, 1, 2, 3, 5, 8, 13, ... Постройте последовательность Фибоначчи длиной 
n (n вводится с клавиатуры). Результат отобразите в виде строки полученных чисел, записанных через пробел. Программу 
реализовать при помощи цикла while.

```python
a, b = 1, 1
n = int(input())
i = 0
while i < n:
    i += 1
    print(a, end=" ")
    a, b = b, a + b
```

## 25.Операторы break, continue, else

<h3 align="center">Оператор прерывания цикла break</h3>

Иногда бывает нужно **прервать выполнение цикла преждевременно**. Оператор `break` прерывает ближайший цикл `for` или `while`.

> Оператор прерывания цикла `break` удобен в связке с сигнальными метками: когда после проверки некоторого условия нам нет смысла продолжать выполнение цикла.

Напишем, программу, которая определяет, содержит ли введенное пользователем число, цифру 7.

```python
num = int(input())
number = num
flag = False
while num != 0:
    last_digit = num % 10
    if last_digit == 7:
        flag = True
        break        # прерываем цикл, так как число гарантированно содержит цифру 7
    num //= 10

if flag == True:
    print('Число', number, 'содержит цифру 7')
else:
    print('Число', number, 'не содержит цифру 7')
```

Как только мы встретили цифру 7, мы меняем значение сигнальной метки и прерываем цикл с помощью оператора `break`.

<h3 align="center">Бесконечные циклы</h3>

Оператор `break` позволяет прерывать бесконечные циклы.

Например, программа, которая постоянно принимает запросы на обслуживание. Программный код такой программы может выглядеть так:

```python
while True:
    query = get_new_query() #  получаем новый запрос на обработку
    query.process()         #  обрабатываем запрос
```

Иногда с помощью бесконечного цикла удается сделать программный код более читабельным. Более простым может быть завершение цикла на основе условий внутри тела цикла,
а не на основе условий в его заголовке:

```python
while True:
    if условие 1:  # условие для остановки цикла
        break
    ...
    if условие 2:  # еще одно условие для остановки цикла
        break
    ...
    if условие 3:  # еще одно условие для остановки цикла
        break
```        
    
В подобных случаях, когда существует множество причин завершения цикла, часто их проще выделить из нескольких разных мест, чем пытаться указать все условия 
завершения в заголовке цикла.

<h3 align="center">Оператор continue</h3>

Другая стандартная идиома циклов — пропуск отдельных элементов при переборе. Оператор `continue` позволяет перейти к следующей итерации цикла `for` или
`while` до завершения всех команд в теле цикла.

Напишем программу, которая выводит все числа от 1 до 100, кроме чисел 7, 17, 29 и 78.

```python
for i in range(1, 101):
    if i == 7 or i == 17 or i == 29 or i == 78:
        continue  # переходим на следующую итерацию
    print(i)
```

<h3 align="center">Блок else в циклах</h3>

Python допускает необязательный блок `else` в конце циклов `while` и `for`.

Синтаксис такой конструкции следующий:

```python
while условие:
    блок кода1
else:
    блок кода2

# или

for i in range(10):
    блок кода1
else:
    блок кода2
```

`Блок кода2`, указанный в `else`, будет выполнен, когда **штатным образом** завершается цикл `while` или `for`. Под **штатным завершением** цикла, подразумевается
его завершение **без** использования оператора прерывания `break`.

Напишем, программу, которая определяет, содержит ли введенное пользователем число, цифру 7. Вместо программного кода, написанного ранее мы можем использовать:

```python
num = int(input())
n = num
while n != 0:
    last = n % 10
    if last == 7:
        print('Число', num, 'содержит цифру 7')
        break
    n //= 10
else:
    print('Число', num, 'не содержит цифру 7')
```

## Задания

1. Напишите программу, которая считывает целые числа с консоли по одному числу в строке. Для каждого введённого числа проверить:
 - если число меньше 10, то пропускаем это число;
 - если число больше 100, то прекращаем считывать числа;
в остальных случаях вывести это число обратно на консоль в отдельной строке.

```python
n = int(input())
while True:
    if n > 100:
        break
    if n < 10:
        n = int(input())
        continue
    print(n)
    n = int(input())
```

2. Сиракузская последовательность, или последовательность Коллатца, строится так: возьмём натуральное число n; если оно чётное,
то заменим его числом n/2; если же оно нечётное, то заменим его числом 3n+1. Получившееся число — следующее в сиракузской 
последовательности после числа n. Затем заменяем получившееся число по тому же правилу, и так далее.
Определите, сколько шагов потребуется сиракузской последовательности, стартующей с заданного числа, чтобы прийти к 1.

```python
n = int(input())
cnt = 0
while True:
    if n == 1:
        break
    cnt += 1
    if n % 2 == 0:
        n //= 2
    else:
        n = 3 * n + 1
print(cnt)
```

3. Вам на вход поступает слово и ваша задача в цикле while обойти все его буквы и распечатать их в формате фразы:

«Текущая буква: <letter>».

Как только вы встретите строчные английские буквы «e» или «a» нужно вывести фразу «Ага! Нашлась», перестать печатать буквы 
и принудительно выйти из цикла.

В случае, если в слове не оказалось букв «e» или «a» необходимо вывести фразу «Распечатали все буквы»
  
```python
s = input()
while s:
    let = s[0]
    if let in ("e", "a"):
        print("Ага! Нашлась")
        break
    print(f'Текущая буква: {let}')
    s = s[1:]
else:
    print("Распечатали все буквы")
```
  
  
4. Имеется одномерный список длиной 10 элементов, состоящий из нулей:

p = [0] * 10

На каждой итерации цикла пользователь вводит целое число - индекс элемента списка p, по которому записывается значение 1, 
если ее там еще нет. Если же 1 уже проставлена, то список не менять и снова запросить у пользователя очередное число. 
Необходимо расставить так пять единиц в список. (После этого цикл прерывается).

Программу реализовать с помощью цикла while и с использованием оператора continue, когда 1 не может быть добавлена в список. 
Результат вывести на экран в виде последовательности чисел, записанных через пробел.
  
```python
p = [0] * 10
while p.count(1) < 5:
    indx = int(input())
    if p[indx] == 1:
        continue
        
    p[indx] = 1
print(*p)
```
                     
                     
5. Вводится список названий городов в одну строчку через пробел. Определить, что в этом списке все города имеют длину более 
5 символов. Реализовать программу с использованием цикла while и оператора break. Вывести ДА, если условие выполняется и НЕТ -
в противном случае.
                     
```python
lst = input().split()
i = 0
while i < len(lst):
    if len(lst[i]) <= 5:
        print("НЕТ")
        break
    i += 1
else:
    print("ДА")
```

6. Вводятся названия книг (каждое с новой строки). Удалить из введенного списка все названия, состоящие из двух и более слов (слова в названиях разделяются пробелом). Результат вывести на экран в виде строки из оставшихся названий через пробел.
P. S. Для считывания списка целиком в программе уже записаны начальные строчки

```python
import sys

# считывание списка из входного потока
lst_in = list(map(str.strip, sys.stdin.readlines()))

i = len(lst_in) - 1
while i >= 0:
    if len(lst_in[i].split()) >= 2:
        del lst_in[i]
    i -= 1
print(*lst_in)
```                       
                       
## 26.Оператор цикла for и функция range
  
<h3 align="center">Цикл for</h3>

В Python существует две основных разновидности циклов:

 - циклы, повторяющиеся определенное количество раз (`for`, счетные циклы, **counting loops**);
 - циклы, повторяющиеся до наступления определенного события (`while`, условные циклы, **conditional loops**).
 
Цикл `for` замечательно работает, если мы заранее знаем, сколько повторений (итераций) нам требуется сделать.

Общий вид цикла for:
  
```python
for <переменная> in <итерируемый объект>:       # заголовок
    # тело цикла
    оператор1
    оператор2
    ...
    операторN
```    
  
Однократное выполнение тела цикла называется **итерацией цикла**.
  
> В общем случае с помощью цикла for происходит перебор итерируемых объектов - объект, предоставляющий возможность поочередного прохода по своим элементам(например,
списки или строки).

<h3 align="center">Примеры использования цикла for</h3>

С помощью цикла for очень легко перебрать список:

```python
lst = [1, 2, 3, 4, 5]

for num in d:
    print(num)
```

```
1
2
3
4
5
```

Или например переберем строку "python":
  
```python
s = "python"

for c in s:
    print(c)
```

```
p
y
t
h
o
n  
```
  
<h3 align="center">Цикл for в деталях</h3>
  
Рассмотрим на примере списка `[1, 2, 3, 4, 5]`

На первой итерации переменная `x` ссылается на первый элемент списка и функция `print` выведет значение в консоль

![image](https://user-images.githubusercontent.com/124737857/229344193-970a73be-b6ae-4598-a739-e302d393e8b7.png)  
  
Далее на следующей итерации, `x` ссылается на следующий элемент списка и функция `print` выведет его
  
![image](https://user-images.githubusercontent.com/124737857/229344229-f0980ca1-4355-493b-8c29-5375403c67ee.png)
  
И так далее будем перебирать элементы списка пока не дойдем до конца.
  
Так как переменная `x` ссылается на элемент списка, то если мы захотим с помощью цикла `for` изменить элементы списка таким образом
  
```python  
for x in [1, 2, 3, 4, 5]:
    x = 0
```
  
то у нас ничего не выйдет.
  
Происходит это потому, что когда выполнится строчка `x = 0`, то это будет означать, что переменная `x` начнет ссылаться на новый объект числовой(`0`), а связь с 
элементом списка будет нарушена(пропадет)
  
![image](https://user-images.githubusercontent.com/124737857/229344307-b76cd492-f716-48eb-813e-34d1b9d87bf6.png)

То есть этим действием мы изменим значение переменной `x`, но не значение элементов списка.

Если необходимо изменить значение элементов списка, то обращаться к ним нужно по индексу, то есть цикл должен перебирать не элементы, а индексы списка.

Для решения такого рода задач существует функция `range`.
  
<h3 align="center">Функция range() с одним параметром</h3>

Рассмотрим изменение элементов списка при помощи функции `range`:
  
```python
lst = [1, 2, 3, 4, 5]
n = len(lst)
  
for i in range(n):
    lst[i] = 0
print(lst)  # [0, 0, 0, 0, 0]
```
  
> В общем случае функция `range(n)` **генерирует последовательность** чисел(итерируемый объект) от `0` до `n - 1`, а цикл `for` последовательно перебирает эту
последовательность.

<h3 align="center">Перегрузка range() с двумя параметрами</h3>

Если мы хотим начинать последовательность не с 0, а с какого-то другого числа, то мы можем использовать **перегрузку функции** `range()` принимающую два параметра.
Например, вызов функции `range(1, 5)` сгенерирует последовательность чисел 1, 2, 3, 4 (правая граница не включительна).

Таким образом:

 - `range(n)`: создает последовательность чисел 0, 1, 2, 3, ..., `n - 1`;
 - `range(n, m)`: создает последовательность чисел `n`, `n + 1`, `n + 2`, ..., `m - 1`.

<h3 align="center">Перегрузка range() с 3 параметрами</h3>

Cуществует еще одна перегрузка функции `range()`, принимающая три параметра: `range(n, m, k)`. Первый параметр задает старт последовательности, второй параметр задает
стоп последовательности и третий – шаг генерации чисел.

Например, вызов функции `range(1, 10, 2)` создаст последовательность чисел 1, 3, 5, 7, 9.

<h3 align="center">Отрицательный шаг генерации</h3>

Если шаг генерации является положительным числом, то генерируемая последовательность будет **возрастать**. Мы можем указать отрицательный шаг генерации (третий 
параметр), что приведет к генерированию **убывающей** последовательности.

В случае отрицательного шага, мы должны гарантировать, что старт последовательности (первый параметр) больше чем конец последовательности (второй параметр).

Например, вызов функции `range(20, 16, -1)` создаст последовательность чисел 20, 19, 18, 17.
  
>  Функция range() может генерировать только целые числа. Величина шага не может равняться нулю.
  
<h3 align="center">Имена переменных цикла</h3>

Ранее говорилось, что имена переменных должны носить осмысленный характер и описывать их назначение. Однако для переменных цикла иногда делается исключения. В
программировании для переменных цикла **обычно** используют буквы `i`, `j`, `k`.

Бывают ситуации когда переменная цикла не используется в теле цикла. В таком случае, вместо того, чтобы давать ей имя, мы можем указать символ нижнего подчеркивания
`_`:
  
```python
for _ in range(3):
    print("python")  
```  

Результатом выполнения такого кода будет:

```
python
python
python
```
  
## Задания
  
1. Вводится список названий городов в одну строчку через пробел. Перебрать все эти названия с помощью цикла for и определить,
начинается ли название следующего города на последнюю букву предыдущего города в списке. Если последними встречаются буквы
'ь', 'ъ', 'ы', то берется следующая с конца буква. Вывести на экран ДА, если последовательность удовлетворяет этому правилу 
и НЕТ - в противном случае.
  
```python
cities = [city.lower().strip("ьъы") for city in input().split()]
for i in range(len(cities) - 1):
    if cities[i][-1] != cities[i + 1][0]:
        print("НЕТ")
        break
else:
    print("ДА")
```
  
2. Напишите программу, которая считывает два натуральных числа a и b (гарантируется, что a < b), после чего для всех чисел от a до b включительно выводит:

 - “Fizz”, если это число делится на 3;
 - “Buzz”, если это число делится на 5;
 - “FizzBuzz”, если выполнены оба предыдущих условия;
 - само это число в остальных случаях.

```python                                                                                                
a, b = int(input()), int(input())
for i in range(a, b + 1):
    s = ""
    if i % 3 == 0: 
        s += 'Fizz'
    if i % 5 == 0: 
        s += 'Buzz'
    print(s if len(s) else i)
``` 
                                                                                                
## 27.Функция enumerate
                                                                                                
Встроенная функция `enumerate()` возвращает кортеж из индекса элемента и самого элемента переданной ей последовательности (итерируемого объекта).

Сигнатура функции следующая: `enumerate(iterable, start)`. В качестве `iterable` может выступать любой итерируемый объект(например, строка или список).
 
С помощью необязательного параметра `start` можно задать начальное значение индекса. По умолчанию значение параметра `start=0`, то есть счет начинается с нуля.

Приведенный ниже код:
                                                                                                
```python
colors = ["red", "green", "blue"]
                                                                                                
for i, item in enumerate(colors):
    print(i, item)
  
for i, item in enumerate(colors, 100):
    print(i, item)                                                                                                
```
  
выведет:
                                                                                                
```
0 red
1 green
2 blue
100 red
101 green
102 blue                                                                                          
```                                                                                                

Функция `enumerate()` возвращает специальный объект, который называется итератором. Такой объект похож на список тем, что его можно перебирать
циклом `for`, то есть итерировать. Итератор можно преобразовать в список с помощью функции `list()`.

Приведенный ниже код:

```python                                                                                                
colors = ["red", "green", "blue"]
                                                                                                
pairs = enumerate(colors)
print(pairs)  # <enumerate object at 0x7fb1be63dd80>
print(list(pairs))  # [(0, 'red'), (1, 'green'), (2, 'blue')]                                                                                           
```                                                                                                
                                                                                         
## Задания                                                                                                
                                                                                                
1. На вход программе подается натуральное число n. Напишите программу, которая вычисляет сумму всех его делителей.
                                                                                                
```python                                                                                                
n = int(input())
total = 0
for i in range(1, int(n ** 0.5) + 1):
    if n % i == 0:
        total += i
        if i != n // i:
            total += n // i
print(total)
```
                                                                                                                                                                                              
2. На вход программе подается натуральное число n, а затем n различных натуральных чисел, каждое на отдельной строке. 
Напишите программу, которая выводит наибольшее и второе наибольшее число последовательности.
                                                                                                
```python                                                                                                
for _ in range(n):
    number = int(input())
    if mx1 < number:
        mx2 = mx1
        mx1 = number
    elif mx2 < number:
        mx2 = number
print(mx1, mx2, sep="\n")
```
                      
3. В первой строке входных данных содержится число n (1 ≤ n ≤ 100) — количество раундов игры.
Следующие n строк содержат описание раундов. В i-й из них содержится пара целых чисел mi и ci (1 ≤ mi,  ci ≤ 6) — результаты
бросков Мишки и Криса в i-ом раунде соответственно.

**Выходные данные**

В случае победы Мишки в единственной строке выведите "Mishka" (без кавычек), а в случае победы Криса выведите "Chris" 
(без кавычек). Если же игра сведётся к ничьей, то выведите "Friendship is magic!^^" (без кавычек).
                      
```python                      
n = int(input())
cnt_mishka = cnt_chris = 0
for _ in range(n):
    a, b = map(int, input().split())
    if a > b:
        cnt_mishka += 1
    elif a < b:
        cnt_chris += 1
if cnt_mishka > cnt_chris:
    print('Mishka')
elif cnt_mishka < cnt_chris:
    print('Chris')
else:
    print('Friendship is magic!^^')                      
```
                                                    
4. Вводится строка. Необходимо найти все индексы фрагмента "ра" во введенной строке. Вывести в строку через пробелы найденные
индексы. Если этот фрагмент ни разу не будет найден, то вывести значение -1.

```python                            
s = input()
l = []
for i in range(len(s) - 1):
    if s[i] == 'р' and s[i + 1] == 'а':
        l.append(i)
print(*l or [-1])
```
                            
5. У нас есть последовательность скобочных символов, состоящая только из символов `(` и `)`
Ваша задача определить является ли введенная скобочная последовательность правильной.
Правильная скобочная последовательность (ПСП) называется строка, состоящая только символов "скобок", где каждой закрывающей 
скобке найдётся соответствующая открывающая. При этом учитывайте, что:
Пустая последовательность является правильной.
 - Если A – правильная скобочная последовательность, то (A) – правильные скобочные последовательности.
 - Если A и B – правильные скобочные последовательности, то AB – правильная скобочная последовательность.
Если введенная строка является ПСП, выведите YES, в противном случае - NO.
                            
```python                            
cnt = 0
sequence = input()
for elem in sequence:
    if elem == "(":
        if cnt < 0:
            print("NO")
            break
        cnt += 1
    else:
        cnt -= 1
else:
    print("YES" if cnt == 0 else "NO") 
```
 
```python
# способ 2(через стек)
stack = []
sequence = input()
for elem in sequence:
    if elem == "(":
        stack.append(elem)
    else:
        if stack:
            stack.pop()
        else:
            print("NO")
            break
else:
    print("YES" if stack == [] else "NO")
```
  
6. В виде строки записано арифметическое выражение, например:
"10 + 25 - 12"
или
"10 + 25 - 12 + 20 - 1 + 3"
и т. д. То есть, количество действий может быть разным.
Необходимо выполнить вычисление и результат отобразить на экране. Полагается, что в качестве арифметических операций здесь 
используется только сложение (`+`) и вычитание (`-`), а в качестве операндов - целые неотрицательные числа. Следует учесть, 
что эти операторы могут быть записаны как с пробелами, так и без них.
  
```python  
a = input().replace(" ","")
s = ''
total = 0
for c in a:
    if c not in '+-':
        s += c
    else:
        total += int(s)
        s = c
print(total + int(s))
```

```python  
# 2 способ
a = input().replace(" ", "").replace("+", " +").replace("-", " -")
print(sum(map(int, a.split())))
```
  
7. Наша программа принимает на вход последовательность скобочных символов. Ваша задача определить является ли введенная 
скобочная последовательность правильной.

Правильная скобочная последовательность (ПСП) называется строка, состоящая только из символов "скобки", где каждой закрывающей 
скобке найдётся соответствующая открывающая (причём того же типа). При этом учитывайте, что:

 - Пустая последовательность является правильной.
 - Если A – правильная скобочная последовательность, то (A), [A] и {A} – правильные скобочные последовательности.
 - Если A и B – правильные скобочные последовательности, то AB – правильная скобочная последовательность.
 - Если введенная строка является ПСП, выведите YES, в противном случае - NO.

```python  
stack = []
sequence = input()
for elem in sequence:
    if elem in "({[":
        stack.append(elem)
    else:
        if not stack:
            print("NO")
            break
        elif stack[-1] + elem not in ("{}", "[]", "()"):
            print("NO")
            break
        else:
            stack.pop()
else:
    print("YES" if stack == [] else "NO")
```
