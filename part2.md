## Содержание
 - [7.Введение в строки. Операции над строками](#7введение-в-строки-операции-над-строками)
 - [8.Представление строк в памяти компьютера, ASCII и Unicode, функции ord и chr](#8представление-строк-в-памяти-компьютера-ascii-и-unicode-функции-ord-и-chr)
 - [9.Индексы и срезы строк](#9индексы-и-срезы-строк)
 - [10.Основные методы строк](#10основные-методы-строк)
 - [11.Спецсимволы и экранирование символов](#11спецсимволы-и-экранирование-символов)
 - [12.Форматирование строк и F-строки](#12форматирование-строк-и-f-строки)
 - [13.F-строки дополнительные возможности](#13f-строки-дополнительные-возможности)
 - [14.Моржовый оператор](#14моржовый-оператор)


## 7.Введение в строки. Операции над строками

<h3 align="center">Строковый тип данных</h3>

В Python строковый тип данных имеет название `str` (сокращение от `string` — струна, ряд). 

Для создания строковой переменной (литерала), мы должны заключить необходимый текст в кавычки. В Python можно использовать как одинарные кавычки, так и двойные:

```python
s1 = "python"
s2 = 'python'
```

<h3 align="center">Длина строки</h3>

Длиной строки называется количество символов из которых она состоит. Чтобы посчитать длину строки используем встроенную функцию `len()` (от слова `length` – длина):

```
s1 = "Hello, world!"
print(len(s1))  # 13
```

<h3 align="center">Конкатенация строк</h3>

Строки, как и числа, можно складывать. Операция сложения строк называется **конкатенацией** или **сцеплением**:

```python
s1 = "ab" + "cd"
s2 = "cd" + "ab"
print(s1)  # abcd
print(s2)  # cdab
```

Операция сложения строк в отличие от операции сложения чисел не является [коммутативной](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BC%D1%83%D1%82%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D1%81%D1%82%D1%8C)

<h3 align="center">Умножение строки на число</h3>

В Python так же можно умножать строку на число. Такой оператор повторяет строку указанное количество раз.

Рассмотрим следующий программный код:

```
s1 = "Hi" * 4
print(s1)  # HiHiHiHi
```

Строку можно умножать на отрицательные числа и 0, тогда результатом будет пустая строка:

```python
>>> s1 = "python" * 0
>>> s1
''
>>> s2 = "python" * -1
>>> s2
''
```

<h3 align="center">Оператор in</h3>

В Python есть специальный оператор `in`, который позволяет проверить, что одна строка находится внутри другой:

```python
s = "abcdef123"
print("1" in s)  # True
print("q" in s)  # False
```

Можно использовать оператор `in` вместе с логическим оператором `not`. 

Например:

```
s = "abcdef123"
print("q" not in s)  # True
```

> Если строка `s1` содержится в строке `s2`, то строка `s1` является подстрокой для строки `s2`. То есть оператор `in` определяет является ли одна строка 
> подстрокой другой.

### Задания:

1. Будем считать email адрес корректным, если в нем есть символ собачки (`@`) и точки. Напишите программу проверяющую 
корректность email адреса. Программа должна вывести строку «YES», если email адрес является корректным и «NO» в ином случае.

```python
email = input()
print("YES" if "@" in email and "." in email else "NO")
```

2. Даны названия трех городов. Напишите программу, которая определяет самое короткое и самое длинное название города.

```python
city1, city2, city3 = input(), input(), input()
if len(city1) > len(city2):
    city1, city2 = city2, city1
if len(city2) > len(city3):
    city2, city3 = city3, city2
if len(city1) > len(city2):
    city1, city2 = city2, city1   
print(city1, city3, sep="\n")
```

```python
# 2 способ(используя ключ в функции max/min)
city1, city2, city3 = input(), input(), input()
print(min(city1, city2, city3, key=len), max(city1, city2, city3, key=len), sep="\n")
```

## 8.Представление строк в памяти компьютера, ASCII и Unicode, функции ord и chr 

<h3 align="center">Представление строк в памяти компьютера</h3>

Любой набор данных в оперативной памяти компьютера должен храниться в виде двоичного числа. Это относится и к строкам, которые состоят из символов. Когда
символ сохраняется в памяти, он сначала преобразуется в цифровой код. И затем этот цифровой код сохраняется в памяти как двоичное число.

За прошедшие годы для представления символов в памяти компьютера были разработаны различные схемы кодирования. Исторически самой важной из этих схем кодирования
является схема кодирования ASCII (American Standard Code for Information Interchange – американский стандартный код обмена информацией).

<h4 align="center">Таблица символов ASCII</h4>

ASCII представляет собой набор из 128 цифровых кодов, которые обозначают английские буквы, различные знаки препинания и другие символы. Например, код ASCII для
прописной английской буквы «А» (латинской) равняется 65.

![image](https://user-images.githubusercontent.com/124737857/228896392-ebfaa03a-beda-4e2a-b3a8-53d3d4b72884.png)

<h4 align="center">ASCII table</h4>

![image](https://user-images.githubusercontent.com/124737857/228896483-bf94f6f3-29f5-46e1-aad7-7678918a1030.png)

Набор символов ASCII был разработан в начале 1960-х годов и в конечном счете принят почти всеми производителями компьютеров. Однако схема кодирования ASCII имеет
ограничения, потому что она определяет коды только для 128 символов. Для того чтобы это исправить, в начале 1990-х годов был разработан набор символов Юникода
(Unicode). Это широкая схема кодирования, совместимая с ASCII, которая может также представлять символы многих языков мира.

<h4 align="center">Таблица символов Unicode</h4>

Таблица символов Unicode представляет собой набор цифровых символов, которые включают в себя знаки почти всех письменных языков мира(китайские иероглифы, математические символы, буквы греческого алфавита, латиницы и кириллицы,
символы музыкальной нотной нотации). Стандарт предложен в 1991 году некоммерческой организацией «Консорциум Юникода».

Стандарт состоит из двух основных частей: универсального набора символов и семейства кодировок (Unicode transformation format, UTF). Универсальный набор символов
перечисляет допустимые по стандарту Unicode символы и присваивает каждому символу код в виде неотрицательного целого числа. Семейство кодировок определяет способы
преобразования кодов символов для хранения на компьютере и передачи.

В Unicode все время добавляются новые символы, а сам размер этой таблицы не ограничен и будет только расти, поэтому сейчас при хранении в памяти одного 
юникод-символа может потребоваться от 1 до 8 байт. Отсутствие ограничений привело к тому, что стали появляться символы на все случаи жизни.

> В Python используется Unicode.

<h3 align="center">Сравнение строк</h3>

К строкам можно применять операторы сравнения(сравнение строк происходит в лексографическом порядке).

Строки будут равны если длина и символы полностью будут совпадать. Регистр букв при данной операции также важен:

```python
print("aaa" == 'aaa')  # True
print("aaa" == "AAA")  # False
print("aaa" == "aa")   # False
```

Строки можно сравнивать также с помощью операторов `>` и `<`. Python сравнивает строки посимвольно. Где код символа больше, та и строка больше.

```python
print("a" > "cde")  # False
print("abc" > "c")  # False
print("a" > "Azz")  # True
```

Если строки начинаются одинаково, но в одной из них присутствует на конце еще 1 символ, то больше будет та строка, у которой больше длина: 

```python
print("abcd" > "abc")  # True
```

<h3 align="center">Функция ord</h3>

Функция `ord` позволяет определить код некоторого символа в таблице символов Unicode. Аргументом данной функции является одиночный символ:

```
print(ord("A"))  # 65
print(ord("a"))  # 97
print(ord("b"))  # 98
```

<h3 align="center">Функция chr</h3>

Функция `chr` позволяет определить по коду символа сам символ. Аргументом данной функции является численный код:

```python
print(chr(102))   # f
print(chr(1024))  # Ѐ
print(chr(68))    # D
```

Функции `ord` и `chr` часто работают в паре. 

Cледующий код выводит все заглавные буквы английского алфавита:

```python
for i in range(26):
    print(chr(ord("A") + i), end=" ")
```

```
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
```

Вызов функции `ord('A')` возвращает код символа «A», который равен 65. Далее на каждой итерации цикла, к данному коду прибавляется значение переменной `i` =
0, 1, 2, ..., 25, а затем полученный код преобразуется в символ с помощью вызова функции `chr`.

Функции `ord` и `chr` являются **взаимнообратными**. Для них выполнены равенства:

```python
chr(ord("A")) = "A"
ord(chr(65)) = 65
```

1. На вход программе подаются два числа a и b. Напишите программу, которая для каждого кодового значения в диапазоне от a до b (включительно), выводит 
соответствующий ему символ из таблицы символов Unicode.

```python
a, b = int(input()), int(input())
for i in range(a, b + 1):
    print(chr(i), end=' ')
```

2. Легион Цезаря, созданный в 23 веке на основе Римской Империи не изменяет древним традициям и использует шифр Цезаря. 
Это их и подвело, ведь данный шифр очень простой. Однако в постапокалипсисе люди плохо знают все тонкости довоенного мира, 
поэтому ученые из НКР не могут понять как именно нужно декодировать данные сообщения. Напишите программу для декодирования 
этого шифра.

**Формат входных данных**

В первой строке дается число n (1≤ n≤ 25) – сдвиг, во второй строке даётся закодированное сообщение в виде строки со 
строчными латинскими буквами.

**Формат выходных данных**

Программа должна вывести одну строку – декодированное сообщение. Обратите внимание, что нужно декодировать сообщение, 
а не закодировать.

```python
n = int(input())
a = input()
for c in a:
    if ord(c) - n >= ord('a'):
        print(chr(ord(c) - n), end='')
    else:
        print(chr(ord(c) - n + 26), end='')
 ```
        
 ## 9.Индексы и срезы строк
 
 <h3 align="center">Индексация строк</h3>

Для этого в Python используются квадратные скобки `[]`, в которых указывается индекс (номер) нужного символа в строке.

Пусть `s = 'Python'`. Таблица ниже, показывает как работает индексация:

| Выражение | Результат |
| ------------- | ------------- |
| s[0] | P |
| s[1] | y |
| s[2] | t |
| s[3] | h |
| s[4] | o |
| s[5] | n |

> Индексация начинается с 0.

В отличие от многих языков программирования, в Python есть возможность работы с отрицательными индексами. Если первый символ строки имеет индекс 0, то последнему
элементу присваивается индекс -1.

| Выражение | Результат |
| ------------- | ------------- |
| s[-6] | P |
| s[-5] | y |
| s[-4] | t |
| s[-3] | h |
| s[-2] | o |
| s[-1] | n |

Таким образом, получаем

![image](https://user-images.githubusercontent.com/124737857/228907519-fa20bb0d-71b2-4ac4-aa73-df4fee83b192.png)

Обращение по несуществующему индексу в строке вызовет ошибку.

Например, `s = 'Python'`, и мы попытаемся обратится к `s[10]`, то получим ошибку:

```python
s = "Python"
print(s[10])
```

Ошибка возникает, поскольку строка содержит всего 6 символов.

<h3 align="center">Итерирование строк</h3>

Очень часто нужно просканировать всю строку целиком, обрабатывая каждый ее символ. Для этого удобно использовать цикл `for`. Напишем программу, которая выводит
каждый символ строки на отдельной строке:

```python
s = "abcdef"
for i in range(len(s)):
    print(s[i])
```

Результатом выполнения такой программы будут строки:

```
a
b
c
d
e
f
```

Мы передаем в функцию `range()` длину строки `len(s)`. В нашем случае длина строки `s`, равна 6. Таким образом, вызов функции `range(len(s))` имеет вид `range(6)` и
переменная цикла `i` последовательно перебирает все значения от 0 до 5. Это означает, что выражение `s[i]` последовательно вернет все символы строки `s`. 
Такой способ итерации строки удобен, когда нам нужен не только сам элемент `s[i]`, но и его индекс `i`.

Если не нужен индекс самого символа, то мы можем использовать более короткий способ итерации:

```python
s = "abcdef"
for c in s:
    print(c)
```

Этот цикл пройдет по строке `s`, придавая переменной цикла `c` значение каждого символа.

```
a
b
c
d
e
f
```

## Срезы строк

<h3 align="center">Срезы строк</h3>

Иногда нужно бывает работать с целыми частями строки, в таком случае мы используем **срезы (slices)**.

Рассмотрим строку `s = 'abcdefghij'`.

![image](https://user-images.githubusercontent.com/124737857/228909440-2dcc4351-241d-4e72-94bc-07a5d20691c8.png)

С помощью среза мы можем получить несколько символов исходной строки, создав диапазон индексов разделенных двоеточием `s[x:y]`.

Следующий программный код:

```python
s = 'abcdefghij'
print(s[2:5])  # cde
print(s[0:6])  # abcdef
print(s[2:7])  # cdefg
```

![image](https://user-images.githubusercontent.com/124737857/228909599-4f8a8a87-8032-4dd0-85d5-4eb444a0891d.png)

При построении среза `s[x:y]` первое число – это то место, где начинается срез (**включительно**), а второе – это место, где заканчивается срез (**невключительно**).
Разрезая строки, мы создаем подстроку, которая по сути является строкой внутри другой строки.

<h4 align="center">Срез до конца, от начала</h4>

Если опустить второй параметр в срезе `s[x:]`, то срез берется до конца строки. Аналогично если опустить первый параметр `s[:y]`, то можно взять срез от начала строки.

Следующий программный код:

```python
s = 'abcdefghij'
print(s[2:])  # cdefghij
print(s[:7])  # abcdefg
```

![image](https://user-images.githubusercontent.com/124737857/228910447-dd2877f1-49c7-4b34-9dcd-95b6e8aca2b1.png)

Срез `s[:]` возвращает ту же строку:

```python
s1 = "hello"
s2 = s1[:]
print(id(s1), id(s2))  # 2954962939632 2954962939632
```

<h4 align="center">Отрицательные индексы в срезе</h4>

Мы также можем использовать отрицательные индексы для создания срезов.

Следующий программный код:

```python
s = 'abcdefghij'
print(s[-9:-4])  # bcdef
print(s[-3:])  # hij
print(s[:-3])  # abcdefg
```

![image](https://user-images.githubusercontent.com/124737857/228911601-9fa38eeb-b50e-46fe-aeb9-72014c71c695.png)

<h4 align="center">Шаг среза</h4>

Мы можем передать в срез третий необязательный параметр, который отвечает за шаг среза. К примеру, срез `s[1:7:2]` создаст строку `bdf` состоящую из каждого второго
символа (индексы 1, 3, 5, правая граница не включена в срез).

![image](https://user-images.githubusercontent.com/124737857/228912092-31d36886-5166-42ba-bddb-e7c301cb6e83.png)

<h4 align="center">Отрицательный шаг среза</h4>

Если в качестве шага среза указать отрицательное число, то символы будут идти в обратном порядке.

```python
s = 'abcdefghij'
print(s[::-1])      # jihgfedcba
print(s[-9:-3:2])   # bdf
print(s[-1:-9:-2])  # jhfd
```

<h3 align="center">Изменение символа строки по индексу</h3>

Предположим, у нас есть строка `s = 'abcdefghij'` и мы хотим заменить символ с индексом 4 на `'X'`. Можно попытаться написать код:

```python
s[4] = "X"
```

Однако такой код не работает. В Python строки являются **неизменяемыми**.

Если мы хотим поменять какой-либо символ строки `s`, мы должны создать новую строку. Следующий код использует срезы и решает поставленную задачу:

```python
s = s[:4] + "X" + s[5:]
```

### Задания:

1. На вход программе подается одна строка. Напишите программу, которая выводит сообщение «Цифра» (без кавычек), если строка 
содержит цифру. В противном случае вывести сообщение «Цифр нет» (без кавычек)."""

```python
s = input()
for c in s:
    if c in '1234567890':
        print('Цифра')
        break
else:
    print('Цифр нет')
```

2. На вход программе подается одна строка. Напишите программу, которая определяет сколько в ней одинаковых соседних символов.

**Формат входных данных**

На вход программе подается одна строка.

**Формат выходных данных**

Программа должна вывести количество одинаковых соседних символов.

```python
s = input()
cnt = 0
for i in range(len(s) - 1):
    if s[i] == s[i + 1]:
        cnt += 1
print(cnt)
```

3. На вход программе подается натуральное число, записанное в десятичной системе счисления. Напишите программу, которая 
переводит данное число в двоичную систему счисления.

```python
s = ""
a = int(input())
while a:
    s += str(a % 2)
    a //= 2
print(s[::-1])
```

```python
# Решение через f-строку
print(f'{int(input()):b}')
```

4. На вход программе подается строка текста. Напишите программу, которая разрежет ее на две равные части, переставит их местами и выведет на экран.

**Формат входных данных**

На вход программе подается строка текста.

**Формат выходных данных**

Программа должна вывести текст в соответствии с условием задачи.

Примечание. Если длина строки нечетная, то длина первой части должна быть на один символ больше.

```python
a = input()
if len(a) % 2 == 1:
    print(a[len(a) // 2 + 1:] + a[:len(a) // 2 + 1])
else:
    print(a[len(a) // 2:] + a[:len(a) // 2])
```
    
## 10.Основные методы строк

<h3 align="center">Методы и функции</h3>

Мы уже знакомы с некоторыми встроенными функциями: `min()`, `max()`, `len()`, `int()`, `float()` и т.д. 

**Метод** — специализированная функция, тесно связанная с объектом. Как и функция, метод вызывается для выполнения отдельной задачи, но он вызывается для 
определенного объекта и “знает” о своем целевом объекте во время выполнения.

Метод вызывается в виде `имя_объекта.имя_метода(параметры)`.

Методы строкового типа данных можно разделить на три группы:

 1. **Конвертация регистра**;
 2. **Поиск и замена**;
 3. **Классификация символов**.
 
<h3 align="center">Конвертация регистра</h3>

Методы в этой группе выполняют преобразование регистра для строк.

<h4 align="center">Метод capitalize()</h4>

Метод `capitalize()` возвращает копию строки `s`, в которой первый символ имеет верхний регистр, а все остальные символы имеют нижний регистр.

Результатом выполнения следующего кода:

```python
s = 'foO BaR BAZ quX'
print(s.capitalize())
```

будет:

```
Foo bar baz qux
```

Символы, не являющиеся буквами алфавита, остаются неизменными. 

Результатом выполнения следующего кода:

```python
s = 'foo123#BAR#.'
print(s.capitalize())
```

будет:

```
Foo123#bar#.
```

<h4 align="center">Метод swapcase()</h4>

Метод `swapcase()` возвращает копию строки `s`, в которой все символы, имеющие верхний регистр, преобразуются в символы нижнего регистра и наоборот.

Результатом выполнения следующего кода:

```python
s = 'FOO Bar 123 baz qUX'
print(s.swapcase())
```

будет:

```
foo bAR 123 BAZ Qux
```

<h4 align="center">Метод title()</h4>

Метод `title()` возвращает копию строки `s`, в которой первый символ каждого слова переводится в верхний регистр.

Результатом выполнения следующего кода:

```python
s = 'the sun also rises'
print(s.title())
```

будет:

```
The Sun Also Rises
```

Этот метод использует довольно простой алгоритм: он не пытается различить важные и неважные слова и не обрабатывает аббревиатуры и апострофы. Результатом выполнения
следующего кода:

```python
s = "what's happened to ted's IBM stock?"
print(s.title())
```

будет:

```
What'S Happened To Ted'S Ibm Stock?
```

<h4 align="center">Метод lower()</h4>

Метод `lower()` возвращает копию строки `s`, в которой все символы имеют нижний регистр.

Результатом выполнения следующего кода:

```python
s = 'FOO Bar 123 baz qUX'
print(s.lower())
```

будет:

```
foo bar 123 baz qux
```

<h4 align="center">Метод upper()</h4>

Метод `upper()` возвращает копию строки `s`, в которой все символы имеют верхний регистр.

Результатом выполнения следующего кода:

```python
s = 'FOO Bar 123 baz qUX'
print(s.upper())
```

будет:

```
FOO BAR 123 BAZ QUX
```

### Задания:

1. На вход программе подается строка. Напишите программу, которая подсчитывает количество буквенных символов в нижнем регистре.

**Формат входных данных**

На вход программе подается строка.

**Формат выходных данных**

Программа должна вывести количество буквенных символов в нижнем регистре.

```python
from string import ascii_lowercase as low

cnt = 0
for c in input():
    if c in low:
        cnt += 1
print(cnt)
```

<h3 align="center">Поиск и замена</h3>

Методы поиска и замены строк внутри других строк.

Каждый метод в этой группе поддерживает необязательные аргументы `<start>` и `<end>`. Как и в строковых срезах действие метода ограничено частью исходной строки,
начинающейся с позиции символа `<start>` и продолжающейся вплоть до позиции символа `<end>`, но не включающей ее. Если параметр `<start>` указан, а параметр `<end>`
нет, то метод применяется к части исходной строки от `<start>` до конца строки. Если параметры не заданы, то подразумевается, что `<start>` = 0 , `<end>` = `len(s)`.

<h4 align="center">Метод count()</h4>

Метод `count(<sub>, <start>, <end>)` считает количество непересекающихся вхождений подстроки `<sub>` в исходную строку `s`.

Результатом выполнения следующего кода:

```python
s = 'foo goo moo'
print(s.count('oo'))
print(s.count('oo', 0, 8))  # подсчет с 0 по 7 символ
```

будет:

```
3
2
```

<h4 align="center">Метод startswith()</h4>
    
Метод `startswith(<suffix>, <start>, <end>)` определяет начинается ли исходная строка `s` подстрокой `<suffix>`. Если исходная строка начинается с подстроки 
`<suffix>` ,метод возвращает значение `True`, а если нет, то `False`.

Результатом выполнения следующего кода:

```python
s = 'foobar'
print(s.startswith('foo'))
print(s.startswith('baz'))
```

будет:

```python
True
False
```

<h4 align="center">Метод endswith()</h4>

Метод `endswith(<suffix>, <start>, <end>)` определяет оканчивается ли исходная строка `s` подстрокой `<suffix>`. Метод возвращает значение `True` если исходная
строка оканчивается на подстроку `<suffix>` и `False` в противном случае.

Результатом выполнения следующего кода:

```python
s = 'foobar'
print(s.endswith('bar'))
print(s.endswith('baz'))
```

будет:

```python
True
False
```

<h4 align="center">Методы find(), rfind()</h4>
    
Метод `find(<sub>, <start>, <end>)` находит **индекс первого вхождения** подстроки `<sub>` в исходной строке `s`. Если строка `s` не содержит подстроки `<sub>`,
то метод возвращает значение -1. Мы можем использовать данный метод наравне с оператором `in` для проверки: содержит ли заданная строка некоторую подстроку или нет.

Результатом выполнения следующего кода:

```python
s = 'foo bar foo baz foo qux'
print(s.find('foo'))
print(s.find('bar'))
print(s.find('qu'))
print(s.find('python'))
```

будет:

```
0
4
20
-1
```

Метод `rfind(<sub>, <start>, <end>)` идентичен методу `find(<sub>, <start>, <end>)`, за тем исключением, что он ищет первое вхождение подстроки `<sub>` начиная с
конца строки `s`.

<h4 align="center">Методы index(), rindex()</h4>

Метод `index(<sub>, <start>, <end>)` идентичен методу `find(<sub>, <start>, <end>)`, за тем исключением, что он **вызывает ошибку** `ValueError: substring not found`
во время выполнения программы, если подстрока `<sub>` не найдена.

Метод `rindex(<sub>, <start>, <end>)` идентичен методу `index(<sub>, <start>, <end>)`, за тем исключением, что он ищет первое вхождение подстроки `<sub>` начиная с
конца строки `s`.

<h4 align="center">Метод strip()</h4>

Метод `strip()` возвращает копию строки `s` у которой удалены все пробелы стоящие в начале и конце строки.

Результатом выполнения следующего кода:

```python
s = '     foo bar foo baz foo qux      '
print(s.strip())
```

будет:

```
foo bar foo baz foo qux
```

<h4 align="center">Метод lstrip()</h4>

Метод `lstrip()` возвращает копию строки `s` у которой удалены все пробелы стоящие **в начале** строки.

Результатом выполнения следующего кода:

```python
s = '     foo bar foo baz foo qux      '
print(s.lstrip())
```

будет:

```
foo bar foo baz foo qux⎵ ⎵ ⎵ ⎵ ⎵ ⎵
```

<h4 align="center">Метод rstrip()</h4>

Метод `rstrip()` возвращает копию строки `s` у которой удалены все пробелы стоящие **в конце** строки.

Результатом выполнения следующего кода:

```python
s = '      foo bar foo baz foo qux      '
print(s.rstrip())
```

будет:

```
⎵ ⎵ ⎵ ⎵ ⎵ ⎵foo bar foo baz foo qux
```

> Методы `strip()`, `lstrip()`, `rstrip()` могут принимать на вход опциональный аргумент `<chars>`. Необязательный аргумент `<chars>` – это строка, которая определяет 
> набор символов для удаления.

<h4 align="center">Метод replace()</h4>

Метод `replace(<old>, <new>)` возвращает копию `s` со всеми вхождениями подстроки `<old>`, замененными на `<new>`.

Результатом выполнения следующего кода:

```python
s = 'foo bar foo baz foo qux'
print(s.replace('foo', 'grault'))
```

будет:

```
grault bar grault baz grault qux
```

Метод `replace()` может принимать опциональный третий аргумент `<count>`, который определяет количество замен.

Результатом выполнения следующего кода:

```python
s = 'foo bar foo baz foo qux'
print(s.replace('foo', 'grault', 2))
```

будет:

```
grault bar grault baz foo qux
```

### Задания:

1. На вход программе подается строка текста, в которой буква «h» встречается минимум два раза. Напишите программу, которая 
удаляет из этой строки первое и последнее вхождение буквы «h», а также все символы, находящиеся между ними.

```python
s = input()
one = s.find('h')
two = s.rfind('h')
s = s.replace(s[one : two + 1], '')
print(s)
```
  
2. Узнав, что ДНК не является случайной строкой, только что поступившие в Институт биоинформатики студенты группы 
информатиков предложили использовать алгоритм сжатия, который сжимает повторяющиеся символы в строке.

Кодирование осуществляется следующим образом:
s = 'aaaabbсaa' преобразуется в 'a4b2с1a2', то есть группы одинаковых символов исходной строки заменяются на этот символ и 
количество его повторений в этой позиции строки.

Напишите программу, которая считывает строку, кодирует её предложенным алгоритмом и выводит закодированную последовательность 
на стандартный вывод. Кодирование должно учитывать регистр символов.

```python
a = input() + ' '
count = 1
for i in range(1, len(a)):
    if a[i-1] == a[i]:
        count += 1
    else:    
        print(a[i-1], count, sep='', end ='')
        count = 1
```
  
3. На вход программе подается строка текста в которой буква «h» встречается как минимум два раза. Напишите программу, 
которая возвращает исходную строку и переворачивает последовательность символов, заключенную между первым и последним 
вхождением буквы «h».

```python
s = input()
a = int(s.find('h'))
b = int(s.rfind('h'))
print(s[:a] + s[b:a:-1] + s[b:])
```
  
4. Петя записался в кружок по программированию. На первом занятии Пете задали написать простую программу. Программа должна 
делать следующее: в заданной строке, которая состоит из прописных и строчных латинских букв, она:

 - удаляет все гласные буквы,
 - перед каждой согласной буквой ставит символ ".",
 - все прописные согласные буквы заменяет на строчные.

Гласными буквами считаются буквы "A", "O", "Y", "E", "U", "I", а согласными — все остальные. На вход программе подается ровно 
одна строка, она должна вернуть результат в виде одной строки, получившейся после обработки.

```python
a = input().upper()
for c in "AOYEUI":
    a = a.replace(c, "")
print("." + ".".join(a.lower()))
```
  
5. Дано пятизначное или шестизначное натуральное число. Напишите программу, которая изменит порядок его последних пяти цифр на
обратный.Число нужно выводить без незначащих нулей.

```python
s = input()
res = ""
if len(s) == 6:
    res += s[0]
    s = s.replace(s[0], "", 1)
print(int(res + s[::-1]))
```

<h3 align="center">Классификация символов</h3>

Методы в этой группе классифицируют строку на основе содержащихся в ней символов.

<h4 align="center">Метод isalnum()</h4>

Метод `isalnum()` определяет, состоит ли исходная строка из буквенно-цифровых символов. Метод возвращает значение `True` если исходная строка является непустой и
состоит только из буквенно-цифровых символов и `False` в противном случае.

Результатом выполнения следующего кода:

```python
s1 = 'abc123'
s2 = 'abc$*123'
s3 = ''

print(s1.isalnum())
print(s2.isalnum())
print(s3.isalnum())
```

будет:

```python
True
False
False
```

<h4 align="center">Метод isalpha()</h4>

Метод `isalpha()` определяет, состоит ли исходная строка из буквенных символов. Метод возвращает значение `True` если исходная строка является непустой и состоит
**только** из буквенных символов и `False` в противном случае.

Результатом выполнения следующего кода:

```python
s1 = 'ABCabc'
s2 = 'abc123'
s3 = ''

print(s1.isalpha())
print(s2.isalpha())
print(s3.isalpha())
```

будет:

```python
True
False
False
```

<h4 align="center">Метод isdigit()</h4>

Метод `isdigit()` определяет, состоит ли исходная строка только из цифровых символов. Метод возвращает значение `True` если исходная строка является непустой и
состоит только из цифровых символов и `False` в противном случае.

Результатом выполнения следующего кода:

```python
s1 = '1234567'
s2 = 'abc123'
s3 = ''

print(s1.isdigit())
print(s2.isdigit())
print(s3.isdigit())
```

будет:

```python
True
False
False
```

<h4 align="center">Метод islower()</h4>

Метод `islower()` определяет, являются ли все буквенные символы исходной строки строчными. Все неалфавитные символы игнорируются!

Результатом выполнения следующего кода:

```python
s1 = 'abc'
s2 = 'abc1$d'
s3 = 'Abc1$D'

print(s1.islower())
print(s2.islower())
print(s3.islower())
```

будет:

```python
True
True
False
```

<h4 align="center">Метод isupper()</h4>

Метод `isupper()` определяет, являются ли все буквенные символы исходной строки заглавными. Все неалфавитные символы игнорируются!

Результатом выполнения следующего кода:

```python
s1 = 'ABC'
s2 = 'ABC1$D'
s3 = 'Abc1$D'

print(s1.isupper())
print(s2.isupper())
print(s3.isupper())
```

будет:

```python
True
True
False
```

<h4 align="center">Метод isspace()</h4>

Метод `isspace()` определяет, состоит ли исходная строка только из пробельных символов.

Результатом выполнения следующего кода:

```python
s1 = '       '
s2 = 'abc1$d'

print(s1.isspace())
print(s2.isspace())
```

будет:

```python
True
False
```

## Некоторые другие полезные методы строк

<h3 align="center">Метод ljust()</h3>

Строковый метод `ljust()` выравнивает текст по ширине, **добавляя пробелы** в конец текста.

Результатом выполнения следующего кода:

```python
print('a'.ljust(3))
print('ab'.ljust(3))
print('abc'.ljust(3))
```

будет:

```
a⎵⎵
ab⎵
abc
```

Строковый метод `ljust()` использует вместо пробела другой символ, если передать ему второй аргумент, необязательный.

Результатом выполнения следующего кода:

```python
print('a'.ljust(5, '*'))
print('ab'.ljust(5, '$'))
print('abc'.ljust(5, '#'))
```

будет:

```
a****
ab$$$
abc##
```

<h3 align="center">Метод rjust()</h3>

Строковый метод `rjust()` выравнивает текст по ширине, добавляя пробелы в начало текста.

Результатом выполнения следующего кода:

```python
print('a'.rjust(3))
print('ab'.rjust(3))
print('abc'.rjust(3))
```

будет:

```
⎵⎵a
⎵ab
abc
```

Строковый метод `rjust()` использует вместо пробела другой символ, если передать ему второй аргумент, необязательный.

Результатом выполнения следующего кода:

```python
print('a'.rjust(5, '*'))
print('ab'.rjust(5, '$'))
print('abc'.rjust(5, '#'))
```

будет:

```
****a
$$$ab
##abc
```

<h3 align="center">Метод split()</h3>

Метод `split()` разбивает строку на слова, используя в качестве разделителя последовательность пробельных символов.

Следующий программный код:

```python
s = 'Python is the most powerful language'
words = s.split()
print(words)
```

выведет: 

```python
['Python', 'is', 'the', 'most', 'powerful', 'language']
```

<h4 align="center">Необязательные параметры</h4>

У метода `split()` есть необязательный параметр, который определяет, какой набор символов будет использоваться в качестве разделителя между элементами списка. 
Например, вызов метода `split('.')` вернет список, полученный разделением исходной строки по символу `'.'`.

Следующий программный код:

```python
ip = '192.168.1.24'
numbers = ip.split('.')    # указываем явно разделитель
print(numbers)
```

выведет список:

```python
['192', '168', '1', '24']
```

<h3 align="center">Метод join()</h3>

Метод `join()` собирает строку из элементов итерируемого объекта(например, списка), используя в качестве разделителя строку, к которой применяется метод.

Следующий программный код:

```python
words = ['Python', 'is', 'the', 'most', 'powerful', 'language']
s = ' '.join(words)
print(s)
```

выведет: 

```
Python is the most powerful language
```

Обратите внимание, все слова разделены одним пробелом, поскольку метод `join()` вызывался на строке состоящей из одного символа пробела `' '`.

Строковый метод `join()` работает с итерируемым объектом, хранящим строки. 

Следующий код приводит к ошибке:

```python
numbers = [1, 2, 3, 4]  # список чисел
s = '*'.join(numbers)
print(s)
```

### Задания:

1. На вход программе подается строка текста, содержащая натуральные числа. Из данной строки формируется список чисел. 
Напишите программу, которая подсчитывает, сколько в полученном списке пар элементов, равных друг другу. Считается, что 
любые два элемента, равные друг другу образуют одну пару, которую необходимо посчитать.

```python
a = input().split()
count = 0
for i in range(len(a) - 1):
    for j in range(i + 1, len(a)):
        if a[i] == a[j]:
            count += 1
print(count)
```
  
## 11.Спецсимволы и экранирование символов

При создании многострочного текста появляется спец символ перевода строки

```python
s = """Hello
world
hi 
bye"""

```

Вывод в IDLE при обращении к переменной будет следующим:

```
'Hello\nworld\nhi\nbye'
```

Также можно и напрямую сохранять в переменную этот служебный символ.

```python
s = "abc\ndf"
```

Кроме `\n` есть еще и другие служебные символы.

Таблица символов приведена ниже:

| Обозначение | Описание |
| ------------- | ------------- |
| `\n` | перевод строки |
| `\\` | символ обратного слеша |
| `\'` | символ апострофа |
| `\"` | символ двойной кавычки |
| `\b` | BackSpace |
| `\r` | возврат коретки |
| `\t` | горизантальная табуляция |
| `\v` | вертикальная табуляция |
| `\0` | Null |

Все служебные символы начинаются на знак обратного слэша и всегда когда python увидит в строке `\`, то он начинает искать соответствие по служебному символу и
отсюда существует правило, что никакую строку нельзя заканчивать обратным слешем.

Если запустить код ниже, то это вызовет ошибку.

```python
s = "abc\"
```

```python
SyntaxError: EOL while scanning string literal
```

Это происходит потому что Python попытается преобразовать экранированную обратную кавычку.

Иногда необходимо, чтобы слеш отображался как слеш, для этого используется экранирование.

Например мы хотим вывести слеши перед и после слова needs:

```python
s = "i \needs\ python"
print(s)
```

Однако получаем такой вывод

```
i 
eeds\ python
```

Экранирование решает проблему:

```python
s = "i \\needs\\ python"
print(s)
```

```
i \needs\ python
```

Часто это необходимо при прописывании пути к файлу.

Например:

```python
print("C:\\new\\data\\test.py")  # C:\new\data\test.py
```

Вместо экранирования символов можно использовать сырые строки (raw strings). Для этого следует снабдить строковый литерал префиксом в виде буквы r.

```python
print(r"C:\new\data\test.py")  # C:\new\data\test.py
```
  
## 12.Форматирование строк и F-строки
  
<h3 align="center">Форматирование строк</h3>

Хранить строки в переменных удобно, но часто бывает необходимо **собирать строки** из других объектов (строк, чисел и т.д.) и выполнять с ними нужные манипуляции.
Для этой цели можно воспользоваться механизмом **форматирования строк**.

Рассмотрим следующий код:

```python
age = 27
txt = 'My name is Timur, I am {}'.format(age)
print(txt)
```

Мы передаем необходимые параметры методу `format`, а Python форматирует указанную строку и помещает их в строку на место заполнителей `{}`. Мы можем создавать 
сколько угодно заполнителей в строке:

```python
age = 27
name = 'Timur'
profession = 'math teacher'
txt = 'My name is {}, I am {}, I work as a {}'.format(name, age, profession)
print(txt)
```

Для наглядности и гибкости форматирования мы можем использовать порядковый номер в заполнителе: `{0}`, `{1}`, `{2}`,.... Такой номер определяет позицию параметра,
переданного методу `format` (нумерация начинается с нуля):

```python
age = 27
name = 'Timur'
profession = 'math teacher'
txt = 'My name is {0}, I am {1}, I work as a {2}'.format(name, age, profession)
print(txt)
```

Параметр `name` встает в `{0}`, параметр `age` встает в `{1}` и т.д. Мы можем использовать одно и тоже число в нескольких заполнителях

```python
name = 'Timur'
txt = 'My name is {0}-{0}-{0}'.format(name)
print(txt)
```

Результатом выполнения такого кода будет:

```
My name is Timur-Timur-Timur
```

Второй вариант использования формата - это именованное использование переменных. Вместо индексов проставляются имена переменных.

```python
name = "Семен"
balance = 32.64

text = "name - {name}, balance - {balance}".format(name=name, balance=balance)
print(text)  # name - Семен, balance - 32.64
```

При таком способе также имена внутри шаблона можно выбрать любые. Можно сократить до переменных n и b, что соответствует первой букве каждого из этих значений.

```python
name = "Семен"
balance = 32.64

text = "name - {n}, balance - {b}".format(n=name, b=balance)
print(text)  # name - Семен, balance - 32.64
```

<h3 align="center">f-строки</h3>

Метод `format` хорошо справляется с задачей форматирования строк, однако если параметров много, то код может показаться немного избыточным

В Python 3.6 появилась новая разновидность строк — так называемые f-строки. Если поставить перед строкой префикс f, в заполнители можно будет включить код, например
имя переменной.

```python
first_name = 'Timur'
last_name = 'Guev'
age = 27
profession = 'math teacher'
affiliation = 'BeeGeek'
print(f'Hello, {first_name} {last_name}. You are {age}. You are a {profession}. You were a member of {affiliation}')
```

На место заполнителя `first_name` встает значение переменной `first_name`, на место заполнителя `last_name` встает значение переменной `last_name` и т.д.

В фигурных скобках f-строк можно использовать абсолютно любые конструкции языка Python, например методы, функции или математические операции:

```python
name = "Семен"
balance = 32.64

text = f"name - {name.upper()}, balance - {balance * 3}"
print(text)  # name - СЕМЕН, balance - 97.92
```

<h3 align="center">Примечания</h3>

**Примечание 1**. [Подробная документация](https://docs.python.org/3/library/string.html#custom-string-formatting) с форматированием строк.

**Примечание 2** [Документация f-строка](https://peps.python.org/pep-0498/)

**Примечание 3** [Статья про f-строки](https://habr.com/ru/company/wunderfund/blog/674866/)
  
## 13.F-строки дополнительные возможности
  
<h3 align="center">F-строки дополнительные возможности</h3>

Начиная с версии Python 3.8 функционал f-строк был дополнен новой возможностью по выводу имён переменных и их значений:

```python
x = 11
y = 98
print(f"{x=} {y=}")  # x=11 y=98
print(f"{x = } {y = }")  # x = 11 y = 98
```

<h3 align="center">Формат вывода дробной части числа</h3>

Встречаются задачи, где нужно вывести только определенное количество знаков после запятой. Допустим, мы хотим вывести ровно три знака после запятой для любого числа.
Но далеко не у всех чисел в представлении есть эти три знака после запятой. У некоторых чисел они есть, у других либо не хватает знаков, либо имеется больше чем
хотелось бы

```python
a = 1/8
b = 1/2
c = 1/3

print(f"{a = }")  # a = 0.125
print(f"{b = }")  # b = 0.5
print(f"{c = }")  # c = 0.3333333333333333
```

F-строки поддерживают [функционал форматирования](https://docs.python.org/3/reference/lexical_analysis.html#f-strings). Мы указываем специальным образом после имени
переменной сколько символов ожидаем увидеть.

```python
a = 1/8
b = 1/2
c = 1/3

print(f"{a = :.3f}")  # a = 0.125
print(f"{b = :.3f}")  # b = 0.500
print(f"{c = :.3f}")  # c = 0.333
```

Запись `a:.3f` говорит, что  переменную `a` нужно представить в вещественном виде (это знак `f`) и отобразить три символа после запятой. Если у переменной `a` 
не хватает символов для трех знаков, проставятся нули. Если символов в избытке, произойдет округление до третьего символа после запятой.

<h3 align="center">Формат вывода целых чисел</h3>

При помощи $f-строк$ мы можем влиять и на отображение целых чисел.

```python
n = 12345

print(f"{n:6d}")
print(f"{n:5d}")
print(f"{n:4d}")
```

```
 12345
12345
12345
```

Запись `n:6d` говорит, что  переменную `n` нужно представить в виде целого числа (это знак  `d`) и на отображение всего числа выделить 6 знаков. Если у переменной
`n` не хватает разрядов до шести, то впереди отображения появятся знаки пробелов. 

Можно вместо пробелов добавить незначащие нули, для этого нужно подписать 0 перед количеством разрядов

```python
n = 12345

print(f"{n:06d}")
print(f"{n:05d}")
print(f"{n:04d}")
```

```
012345
12345
12345
```

Можно также влиять на знак разделителя между группами чисел:

```python
n = 123456652734

print(f"{n:,d}")  # 123,456,652,734
print(f"{n:_d}")  # 123_456_652_734
```

Если указать другие знаки разделителя вместо знаков `,` и `_` будет ошибка

<h3 align="center">Выравнивание</h3>

Существует несколько способов выравнивания переменных в $f-строках$. 

Различные варианты выравнивания следующие:

| Символ | Значение |
| ------------- | ------------- |
| < | по левому краю(по умолчанию для строк) |
| > | по правому краю(по умолчанию для чисел) |
| ^ | по центру |

Ниже приведен пример использования выравнивания как для чисел, так и для строк.

```python
num = 123
s = "abc"

print(f"{num:10}")
print(f"{num:<10}")
print(f"{num:>10}")
print(f"{num:^10}")

print(f"{s:10}")
print(f"{s:<10}")
print(f"{s:>10}")
print(f"{s:^10}")
```

```
       123
123       
       123
   123    
abc       
abc       
       abc
   abc    
```

По умолчанию символом заполнителем является пробел, но можно его заменить на другое значение

```python
num = 123
s = "abc"

print(f"{num:-<10}")
print(f"{num:=>10}")
print(f"{num:_^10}")

print(f"{s:.<10}")
print(f"{s:+>10}")
print(f"{s:,^10}")
```

```
123-------
=======123
___123____
abc.......
+++++++abc
,,,abc,,,,
```


## 14.Моржовый оператор

Моржовый (walrus) оператор, появившийся в Python 3.8, дает возможность решить сразу две задачи: присвоить значение переменной и вернуть это значение, поэтому порой
можно написать код короче и сделать его более читаемым, и он может быть даже более эффективным с точки зрения вычислений.

**Простой оператор присваивания**

Присвоение значения переменной делается с помощью простого оператора присваивания:

```python
num = 15
print(num)
```

**Моржовый оператор**

Добавленный в Python 3.8 моржовый оператор (`:=`), формально известен как оператор присваивания выражения. Он дает возможность присвоить переменные в выражении, 
включая переменные, которых еще не существует.

> Выражение вычисляется как значение. А инструкция выполняет какое-то действие.

Другими словами, моржовый оператор позволяет нам как присваивать значение переменной, так и возвращать это значение в одном и том же выражении. 


```python
name := expr
```

`expr` вычисляется, а затем присваивается имени переменной. Это значение и будет возвращено.

**Простой пример**

Как и выше, мы хотим присвоить 15 переменной num, а затем вывести значение num. Мы можем выполнить обе эти задачи в одной строке кода, используя новый оператор
следующим образом:

```python
print(num := 15)
```

Значение 15 присваивается `num`. Затем возвращается то же значение, которое становится аргументом для функции print. Таким образом, выводится 15.


**Другой пример**

Допустим, мы хотим продолжить запрашивать какие-то данные у пользователя. Если пользователь ничего не вводит, мы можем перестать запрашивать дополнительный ввод.
Сделать это с помощью цикла while можно следующим образом:

```python
value = input()

while value != "":
    print("Nice")
    value = input()
```

Мы просим пользователя ввести что-нибудь и присваиваем вводу значение. Затем создаем цикл `while`, который выполняется до тех пор, пока введенное значение не пустая
строка. Мы выводим «Nice!», если пользователь успешно ввел что-то. Зачем мы запрашиваем у пользователя следующий ввод, присваиваем ему значение и перезапускаем
процесс.

Давайте попробуем сделать это с помощью моржового оператора:

```python
while (value := input()) != "":
    print("Nice")
```

Мы запрашиваем у пользователя входные данные и присваиваем их с помощью моржового оператора. Значение это позже возвращается и сравнивается с пустой строкой. 
Если в результате сравнения приходит True (то есть не равно пустой строке), код в цикле while выполняется и выводится «Nice!». Если приходит False, то дальнейший код
не выполняется.

<h3 align="center">Примечание</h3>

**Примечание 1** [Документация](https://docs.python.org/3/whatsnew/3.8.html)

**Примечание 2** Подробнее о [моржовом операторе](https://habr.com/en/company/skillfactory/blog/683418/) и [тут](https://python-scripts.com/python-3-8-version?ysclid=l7hiwxa8gh897997020)
